var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Cited-References","page":"References","title":"Cited References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"The following references are cited in the documentation.","category":"page"},{"location":"references.html","page":"References","title":"References","text":"F. Aichouche, N. Kalboussi, A. Rapaport, J. Harmand (2020). Modeling and optimal control for production-regeneration systems - preliminary results -, 2020 European Control Conference (ECC)\nB. Benyahia, A. Charfi, N. Benamar, M. Heran, A. Grasmick, B. Cherki, J. Harmand (2013). A simple model of anaerobic membrane bioreactor for control design: coupling the “AM2b” model with a simple membrane fouling dynamics, World Congress on Anerobic Digestion: Recovering (bio) Ressources for the World\nN.G. Cogan, S. Chellam (2014) A method for determining the optimal back-washing frequency and duration for dead-end microfiltration, Journal of Membrane Science\nN.G. Cogan, J. Li, A. R. Badireddy, S. Chellam (2016) Optimal backwashing in dead-end bacterial microfiltration with irreversible attachment mediated by extracellular polymeric substances production, Journal of Membrane Science\nF. Ellouze, Y. Kammoun, N. Kalboussi, A. Rapaport, J. Harmand, S. Nasr, N. Ben Amar (2023) Optimal control of backwash scheduling for pumping energy saving: Application to the treatment of urban wastewater, Journal of Water Process Engineering\nN. Kalboussi, A. Rapaport, T. Bayen, N. Ben Amar, F. Ellouze, J. Harmand (2017) Optimal control of a membrane filtration system, IFAC-PapersOnLine\nN. Kalboussi, J. Harmand, A. Rapaport, T. Bayen, F. Ellouze, N. Ben Amar (2018) Optimal control of physical backwash strategy - towards the enhancement of membrane filtration process performance, Journal of Membrane Science","category":"page"},{"location":"dev-filtration.html#dev-filtration","page":"Developpers","title":"Filtration.jl private functions","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-filtration.html#Index","page":"Developpers","title":"Index","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Pages   = [\"dev-filtration.md\"]\nModules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-filtration.html#Documentation","page":"Developpers","title":"Documentation","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Modules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-filtration.html#Filtration.cuts-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.cuts","text":"cuts(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> Tuple{SciMLBase.ODESolution, SciMLBase.ODESolution}\n\n\nCompute the cuts c_-(t) and c_+(t), which corresponds to the curves which leads to the singular state x_s at time T. The function c is the solution on t_0 T of\n\nleft beginarrayll\n    dot x_0 = e_-(x_1) - e_+(x_1)  quad x_0(T) = 0 dot x_1 = f_-(x_1) - f_+(x_1)  quad x_1(T) = x_s dot x_2 = g_-(x_1) - g_+(x_1)  quad x_2(T) = x_f- Delta_x\nendarray right\n\nand the function m is the solution on T t_f of \n\nleftbeginarrayll\n    dot x_0 = e_-(x_1) + e_+(x_1)  quad x_O(T) = 0 dot x_1 = f_-(x_1) + f_+(x_1)  quad x_1(T) = x_s dot x_2 = g_-(x_1) + g_+(x_1)  quad x_2(T) = x_f - Delta_x\nendarray right\n\nwarning: Warning\nThe cost x_0(T) at time T is initialized to 0. \n\nArguments\n\nmodel : a Model\nxlim : the limits of state x_2\nylim : the limits of state x_1 \n\nReturns\n\ncut₋ : the function c_-\ncut₊ : the function c_+\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.dispersial_locus-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}, Union{Function, SciMLBase.ODESolution}, Real}","page":"Developpers","title":"Filtration.dispersial_locus","text":"dispersial_locus(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real},\n    SL::Union{Function, SciMLBase.ODESolution},\n    SL_end::Real;\n    method\n) -> Union{Filtration.var\"#DL#43\"{Model}, SciMLBase.ODESolution}\n\n\nCompute the dispersial locus function, with respect to the method given in argument.\n\nArguments\n\nmodel : a Model\nxlim : the limits of state x_2\nylim : the limits of state x_1\nSL : the switching locus, as an ODESolution\nSL_end : the end of the switching locus (on x_2)\n\nKeyword arguments (optional)\n\nmethod : the method to compute the dispersial locus, initialized to :continuation. See available_methods for the list of available methods\n\nReturns\n\nDL : the dispersial locus function\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.dispersial_locus_continuation-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}, Union{Function, SciMLBase.ODESolution}, Real}","page":"Developpers","title":"Filtration.dispersial_locus_continuation","text":"dispersial_locus_continuation(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real},\n    SL::Union{Function, SciMLBase.ODESolution},\n    SL_end::Real\n) -> SciMLBase.ODESolution\n\n\nDispersial locus function computed by continuation method.\n\nA state x_1 x_2 belongs to the dispersial curve if S(x_2 x_1) = 0, where S colon mathbb R^2 to mathbb R is defined by \n\nS(x_1 x_2) = varphi_0^+(x_1 x_2) - varphi_0^-+(x_1 x_2)\n\nwhere varphi_0^+ correponds to the final cost with the control u₊, and where varphi_0^-+ the final cost with the control u₋ ∘ u₊.  \n\nWe suppose that there exsits the switching locus DL(x_1) such that S(x_1 DL(x_1)) = 0. Since S is constant, we have \n\n    fracpartial Spartial x_1(x_1 DL(x_1)) + fracpartial Spartial x_2(x_1 DL(x_1)) DL(x_1) = 0\n\nBy the previous hypothesis, fracpartial Spartial x_2(x_1 DL(x_1)) is invertible. We have so \n\nDL(x_1) = -left( fracpartial Spartial x_2(x_1 DL(x_1)) right)^-1 fracpartial Spartial x_1(x_1 DL(x_1))\n\nThe continuation method consists to solve this ODE with the initial condition DL(x_s) = x_f - Delta x_2. Thanks to the combinaison of ForwardDiff and OrdinaryDiffEq package, the derivative of varphi_0^+ and varphi_0^-+ are computed by automatic differentiation methods by using the variational equations. \n\nwarning: Warning\nThis function must be used only when a dispersial locus happened, ie. when the end of the switching curve (given by the end_switching_locus function) is below ylim[2]. \n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.dispersial_locus_direct-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}, Union{Function, SciMLBase.ODESolution}, Real}","page":"Developpers","title":"Filtration.dispersial_locus_direct","text":"dispersial_locus_direct(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real},\n    SL::Union{Function, SciMLBase.ODESolution},\n    SL_end::Real\n) -> Filtration.var\"#DL#43\"{Model, var\"#s182\", var\"#s1821\", _A, <:Real} where {var\"#s182\"<:Tuple{Real, Real}, var\"#s1821\"<:Tuple{Real, Real}, _A}\n\n\nConstruct the dispersial locus function by direct method.\n\nArguments\n\nmodel : a Model\nxlim : the limits of state x_2\nylim : the limits of state x_1\nSL : the switching locus, as an ODESolution\nSL_end : the end of the switching locus (on x_2)\n\nReturns\n\nDL : the dispersial locus function\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.dispersial_locus_direct_function-Tuple{Real, Model, Tuple{Real, Real}, Tuple{Real, Real}, Union{Function, SciMLBase.ODESolution}, Real}","page":"Developpers","title":"Filtration.dispersial_locus_direct_function","text":"dispersial_locus_direct_function(\n    m::Real,\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real},\n    SL::Union{Function, SciMLBase.ODESolution},\n    SL_end::Real\n) -> Real\n\n\nDispersial locus function by direct method, which corresponds to the curve where the cost associated to u₋ ∘ u₊ is equal to the cost associated to u₊. This function is parametrized like DL(x_1) = x_2\n\nFrom x_1 fixed, we find a zero of the function S colon mathbb R to mathbb R defined by S(x_2) = varphi_0^+(x_1 x_2) - varphi_0^-+(x_1 x_2) where varphi_0^+ correponds to the final cost with the control u₊, and where varphi_0^-+ the final cost with the control u₋ ∘ u₊.  \n\nwarning: Warning\nThis function must be used only when a dispersial locus happened, ie. when the end of the switching curve (given by the end_switching_locus function) is below ylim[2]. \n\nArguments\n\nx₁ : the state x_₁\nmodel : a Model\nxlim : the limits of state x_2\nylim : the limits of state x_1\nSL : the switching locus, as an ODESolution\nSL_end : the end of the switching locus\n\nReturn\n\nx₂ : the state x_2\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.end_switching_locus_direct-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.end_switching_locus_direct","text":"end_switching_locus_direct(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> Real\n\n\nEnd of the switching locus function SL(x_1) = x_2 computed by direct method\n\nThis end point x_1 is given by finding a root of \n\n    SL(x_1) * (f(x_1) - f(x_1)) - (g(x_1) - g(x_1))\n\nSince a rootfinding function is used in the computation of the switching locus function, the derivative of SL is computed by finite differences method, thanks to the FiniteDifferences package. \n\nnote: Note\nIf no end of switching locus is found, the value return is the maximum limits of y, ie. ylim[2]. \n\nArguments\n\nmodel: a Model\nxlim : the limits of the state x_2\nylim : the limits of the state x_1\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for x_1, initialized to the singular state x_s if not provided\n\nReturn\n\nx₁ : the end of the switching locus\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve","text":"solve(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real;\n    cut₋,\n    cut₊,\n    SL,\n    DL,\n    SL_end\n) -> SciMLBase.ODESolution\n\n\nSolve the optimal control problem associated to a Model model by indirect shooting.\n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve_MP-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve_MP","text":"solve_MP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real;\n    SL\n) -> SciMLBase.ODESolution\n\n\nSolve the optimal control problem associated to a Model model by indirect method, with the structure given by u_- circ u_+, and when the change is done by intersection with the switching curve\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve_MSP-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve_MSP","text":"solve_MSP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> SciMLBase.ODESolution\n\n\nSolve the optimal control problem associated to a Model model, with the structure given by u_- circ u_s circ u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve_P-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve_P","text":"solve_P(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> SciMLBase.ODESolution\n\n\nSolve the optimal control problem associated to a Model model, with the structure given by u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve_PSP-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve_PSP","text":"solve_PSP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> SciMLBase.ODESolution\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting,  with the structure given by u_+ circ u_s circ u_+\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead.  \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0) \n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.switching_locus-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.switching_locus","text":"switching_locus(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real};\n    method,\n    initial_guess\n) -> Union{Filtration.var\"#SL#84\"{<:Real, Model, <:Tuple{Real, Real}}, SciMLBase.ODESolution}\n\n\nProvide the switchig locus with respect to the method. To see all method available, please use available_methods function.\n\nArguments\n\nmodel: a Model\nxlim : limits for state x_2\nylim : limits for state x_1\n\nKeyword arguments (optional)\n\nmethod : method used to compute the switching locus, initialized to :continuation\ninitial_guess : initial guess for x_1f, initialized to the singular state x_s if not provided, only used if method = :direct\n\nReturn\n\nSL : the switching locus\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.switching_locus_continuation-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.switching_locus_continuation","text":"switching_locus_continuation(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> SciMLBase.ODESolution\n\n\nSwitching locus function computed by continuation method.\n\nA state x_1 x_2 belongs to the switching curve if S(x_2 x_1) = 0, where S colon mathbb R^2 to mathbb R is defined by \n\nS(x_2 x_1) = H(x_1 varphi_1(x_1 x_2))\n\nThe function varphi_1 coresponds to the solution at the final time of the state x_1 by applying the control u_+, and the function H is defined by \n\n    H(x_1 x_1f) = lambda_1(x_1 x_1f) (f_+(x_1) + f_-(x_1)) + lambda_2(x_1f)(g_+(x_1) + g_-(x_1)) - (e_+(x_1) + e_-(x_1))\n\nwhere \n\n    lambda_1(x_1 x_1f) = frace_+(x_1) - lambda_2(x_1f) g_+(x_1)f_+(x_1)\n\nand \n\n    lambda_2(x_1f) =  frace_+(x_1) + e_-(x_1)g_+(x_1) + g_-(x_1) \n\nWe suppose that there exsits the switching locus SL(x_1) such that S(x_1 SL(x_1)) = 0. Since S is constant, we have \n\n    fracpartial Spartial x_1(x_1 SL(x_1)) + fracpartial Spartial x_2(x_1 SL(x_1)) SL(x_1) = 0\n\nBy the previous hypothesis, fracpartial Spartial x_2(x_1 SL(x_1)) is invertible. We have so \n\nSL(x_1) = -left( fracpartial Spartial x_2(x_1 SL(x_1)) right)^-1 fracpartial Spartial x_1(x_1 SL(x_1))\n\nThe continuation method consists to solve this ODE with the initial condition SL(x_s) = x_f - Delta x_2. Thanks to the combinaison of ForwardDiff and OrdinaryDiffEq package, the derivative of varphi_1 is computed by automatic differentiation methods by using the variatomal equations. \n\nArguments\n\nmodel: a Model\nxlim : the limits of the state x_2\nylim : the limits of the state x_1\n\nReturn\n\nSL : the switching locus function, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.switching_locus_direct-Tuple{Model, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.switching_locus_direct","text":"switching_locus_direct(\n    model::Model,\n    xlim::Tuple{Real, Real};\n    initial_guess\n) -> Filtration.var\"#SL#84\"{<:Real, Model, <:Tuple{Real, Real}}\n\n\nWrapper for the switching locus by direct method, computed by switching_locus_direct_function.\n\nArguments\n\nmodel : a Model\nxlim : the limits of the state x_2\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for x_1f, initialized to the singular state x_s if not provided\n\nRetrun\n\nSL : the switching locus\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.switching_locus_direct_function-Tuple{Real, Model, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.switching_locus_direct_function","text":"switching_locus_direct_function(\n    x₁::Real,\n    model::Model,\n    xlim::Tuple{Real, Real};\n    initial_guess\n) -> Real\n\n\nSwitching locus function SL(x_1) = x_2 computed by direct method\n\nFrom a given state x_1 which belongs to this switching curve, the associated final state x_1f is computed by finding a zero of \n\n    H(x_1 x_1f) = lambda_1(x_1 x_1f) (f_+(x_1) + f_-(x_1)) + lambda_2(x_1f)(g_+(x_1) + g_-(x_1)) - (e_+(x_1) + e_-(x_1))\n\nwhere \n\n    lambda_1(x_1 x_1f) = frace_+(x_1) - lambda_2(x_1f) g_+(x_1)f_+(x_1)\n\nand \n\n    lambda_2(x_1f) =  frace_+(x_1) + e_-(x_1)g_+(x_1) + g_-(x_1) \n\nFrom the final state x(t_f) = x_1f x_f, the state x(T) is computed by a backward integration of the dynamic which stop when x_1(t) = x_1, thanks to a ContinuousCallback. \n\nwarning: Warning\nThe given state x_1 must belong to the switching locus curve, ie. x_s leq x_1 leq x_d where x_s is the singular state, given by model.xₛ, and where x_d is the end of the dispersial locus, computed by the end_switching_locus function.   \n\nArguments\n\nx₁ : the state x_1\nmodel : a Model\nxlim : the limits of the state x_2\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for x_1f, initialized to the singular state x_s if not provided\n\nRetrun\n\nx₂ : the state x_2\n\n\n\n\n\n","category":"method"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Filtration\nusing Plots","category":"page"},{"location":"examples.html#Max-volume-case","page":"Examples","title":"Max volume case","text":"","category":"section"},{"location":"examples.html#Benyahia-et-al.,-2013","page":"Examples","title":"Benyahia et al., 2013","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Benyahia et al., 2013] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,10); mlim = (0,10)\na = 1; b = 1; e = 1\nf₁(m) = b / (e + m)\nf₂(m) = a * m\ng(m)  = 1 / (e + m)\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = g(m)\ng₋(m) = 0\n\nmodel = Model(g₊, g₋, f₊, f₋, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Cogan-Chellamb,-2014","page":"Examples","title":"Cogan Chellamb, 2014","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Cogan and Chellamb, 2014] and [Cogan and al., 2016] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,40); mlim = (0,10)\na = 1; b = 1; e = 1\n\nf₁(m) = b ./ (e .+ m)\nf₂(m) = (a .* m) ./ (e .+ m)\ng(m) = 1 ./ (e .+ m)\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = g(m)\ng₋(m) = 0\n\nmodel = Model(g₊, g₋, f₊, f₋, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Kalboussi-et-al.,-2018","page":"Examples","title":"Kalboussi et al., 2018","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Kalboussi et al., 2018] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0, 0.25); mlim = (0,10)\na₂ = 0.64; b = 490.07; d = 4125.6; e = 18.06\n\nf₁(m) = b./ (e .+ m)\nf₂(m) = (a₂ * d * m) ./ (e .+ m)\ng(m) = d ./ (e .+ m)\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = g(m)\ng₋(m) = 0\n\nmodel = Model(g₊, g₋, f₊, f₋, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Min-energy-example","page":"Examples","title":"Min energy example","text":"","category":"section"},{"location":"examples.html#Aiouche-et-al.,-2020","page":"Examples","title":"Aiouche et al., 2020","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Aiouche et al., 2020] : ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0,50); mlim = (0,50)\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\n\nfp(m) = -ap*m + bp\nfr(m) = ar*m\nlp(m) = cp*m + dp\nlr(m) = cr*m + dr\n\nf₊(m) = 0.5*(fp(m) + fr(m))\nf₋(m) = 0.5*(fp(m) - fr(m))\ng₊(m) = 0.5*(Qp + Qr)\ng₋(m) = 0.5*(Qp - Qr)\ne₋(m) = 0.5*(lp(m) + lr(m))\ne₊(m) = 0.5*(lp(m) - lr(m))\n\nmodel = Model(e₊, e₋, f₊, f₋, g₊, g₋, :min; initial_guess = 20.)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Ellouze-et-al.,-2023","page":"Examples","title":"Ellouze et al., 2023","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Ellouze et al., 2023] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0, 0.015); mlim = (0, 0.05)\nJv = 2.71e-6; JBW = 5.66e-6; TMP01 = 7892.4; Rm = 1.79e12\nC = 2184e-3; β = 1e-6; α = 2.02e14; η = 4.9e-3\nk1f = 2.0769; k2f = 0.0185; k1BW = 9.0551; k2BW = 0.0870\n\nff(m) = C*Jv - C*Jv*β*m\nfBW(m) = -η*m\nEf(m) = k1f * m + k2f\nEBW(m) = k1BW * m + k2BW\n\nf₊(m) = 0.5*(ff(m) - fBW(m))\nf₋(m) = 0.5*(ff(m) + fBW(m))\ng₊(m) = 0.5*(Jv + JBW)\ng₋(m) = 0.5*(Jv - JBW)\ne₊(m) = 0.5*(Ef(m) - EBW(m))\ne₋(m) = 0.5*(Ef(m) + EBW(m))\n\nmodel = Model(e₊, e₋, f₊, f₋, g₊, g₋, :min; initial_guess = 20.)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, SL_nb_points = 10, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"basic-usage.html#Basic-usage","page":"Basic Usage","title":"Basic usage","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The goal of the Filtration.jl package is to provide optimal systesis and optimal solution for a large classe of optimal control problems used for membrane filtration process. There exists mainly two formulation of such optimal control problem which can be found in the litterature.  ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThe provided function given by Filtration.jl package can work whatever the inputs functions are. However, we need to be sure that there exists solutions for this kind of problems and that there exist exacly one root on the domain of interest of a function given by the check_root function. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Here is the used packages to run this page. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"using Filtration\nusing Plots\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Max-volume-case","page":"Basic Usage","title":"Max volume case","text":"","category":"section"},{"location":"basic-usage.html#General-description","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Let us consider the membrane filtration process where the goal is to maximize the water net production ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    max_x(cdot) u(cdot) int_t_0^t_f g_+(m(t)) u(t) + g_-(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = f_+(m(t)) u(t) + f_-(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"with the initial condition m(0) = m_0 and where the initial time t_0 and the final time t_f are fixed. ","category":"page"},{"location":"basic-usage.html#Example","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Benyahia et al., 2013] model, where the functions are defined on the following code section. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThe function 'check_root' and 'Model' need the functions of the model in inputs. The order of these functions is importants. We need to provide first the two function associated to the cost, and after the function(s) associated to the state(s). The (first) state corresponds to the state that is used on the dynamic of all functions. For the order of the couple of functions, we need to provide first the function that multiply the control u. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the check_root function to ensure that there exsit a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"a = 1; b = 1; e = 1;\nf₁(m) = b / (e + m)\nf₂(m) = a * m\ng(m)  = 1 / (e + m)\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = g(m)\ng₋(m) = 0\n\ncheck_root(g₊, g₋, f₊, f₋, :max)","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the MaxVolume. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = Model(g₊, g₋, f₊, f₋, :max, initial_guess = 2.)\nnothing # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be constructed by the Synthesis function. Two methods are proposed to compute the switching and the dispersial locus, which are given by the avaialble_method function. The :continuation one are prefed, and leads to more precise results. The sysnthesis can be plotted simply by plot the created synthesis. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"tlim = (0,10); mlim = (0,10)\nsynthesis = Synthesis(model, tlim, mlim)\nplt = plot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"basic-usage.html#Solution-trajectories","page":"Basic Usage","title":"Solution trajectories","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function solution extract from the synthesis the optimal trajectory, as an ODESolution. We can easily add some optimal state trajectories on the previous created plot.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThis ODESolution contains 3 states. The third state corresponds to the time. Please use this state for plotting, as shown as follow.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"for m0 ∈ range(mlim[1], mlim[2])\n    sol = solution(synthesis, tlim[1], tlim[2], m0)\n    t = [x[3] for x ∈ sol.u]\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nfor t0 ∈ range(tlim[1], tlim[2])\n    sol = solution(synthesis, t0, tlim[2], mlim[1])\n    t = [x[3] for x ∈ sol.u]\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nfor t0 ∈ range(tlim[1], 7.5, 10)\n    sol = solution(synthesis, t0, tlim[2], mlim[2])\n    t = [x[3] for x ∈ sol.u]\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nplt","category":"page"},{"location":"basic-usage.html#Min-Energy-case","page":"Basic Usage","title":"Min Energy case","text":"","category":"section"},{"location":"basic-usage.html#General-description-2","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can also consider another case where the goal is to minimize the energy ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    min_x(cdot) u(cdot) t_f int_t_0^t_f e_+(m(t)) u(t) + e_-(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = f_+(m(t)) u(t) + f_-(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We also want to obtain a final volume v(t_f) = v_f of water at the final time t_f. The dynamic of the state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot v(t) = g_+(m(t)) u(t) + g_-(m(t)) quad t in t_0 t_f ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The initial time t_0 is fixed but the final time t_f is free. ","category":"page"},{"location":"basic-usage.html#Example-2","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Aiouche et al., 2020] model, where the functions are defined on the following code section.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the check_root function to ensure that there exsit a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"# Aiouche model\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\nfp(m) = -ap*m + bp\nfr(m) = ar*m\nlp(m) = cp*m + dp\nlr(m) = cr*m + dr\n\nf₊(m) = 0.5*(fp(m) + fr(m))\nf₋(m) = 0.5*(fp(m) - fr(m))\ng₊(m) = 0.5*(Qp + Qr)\ng₋(m) = 0.5*(Qp - Qr)\ne₋(m) = 0.5*(lp(m) + lr(m))\ne₊(m) = 0.5*(lp(m) - lr(m))\n\ncheck_root(e₊, e₋, f₊, f₋, g₊, g₋, :min; xlim = (0, 30))","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the Model. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = Model(e₊, e₋, f₊, f₋, g₊, g₋, :min; initial_guess = 20.)\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis-2","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be constructed by the Synthesis function, and plotted thanks to the Plot one. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"vlim = (0,50); mlim = (0,50)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"basic-usage.html#Solutions-trajectories","page":"Basic Usage","title":"Solutions trajectories","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function solution extract from the synthesis the optimal trajectory, as an ODESolution. We can easily add some optimal state trajectories on the previous created plot.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"for m0 ∈ range(mlim[1],mlim[2], 10)\n    sol = solution(synthesis, vlim[1], vlim[2], m0)\n    v = [x[3] for x ∈ sol.u]\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, v, m, color = :Gray, label = \"\")\nend\nfor v0 ∈ range(vlim[1],vlim[2], 10)\n    sol = solution(synthesis, v0, vlim[2], mlim[1])\n    v = [x[3] for x ∈ sol.u] \n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, v, m, color = :Gray, label = \"\")\nend\nfor v0 ∈ range(vlim[1],30, 7)\n    sol = solution(synthesis, v0, vlim[2], mlim[2])\n    v = [x[3] for x ∈ sol.u] \n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, v, m, color = :Gray, label = \"\")\nend\nplt","category":"page"},{"location":"index.html#Filtration-Package","page":"Introduction","title":"Filtration Package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Filtration.jl package.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"},{"location":"api-filtration.html#Filtration.jl-API","page":"API","title":"Filtration.jl API","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-filtration.html","page":"API","title":"API","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-filtration.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Pages   = [\"api-filtration.md\"]\nModules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-filtration.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Modules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-filtration.html#Filtration.Filtration","page":"API","title":"Filtration.Filtration","text":"Filtration module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataInterpolations\nDocStringExtensions\nFiniteDifferences\nForwardDiff\nLaTeXStrings\nMINPACK\nNemo\nOptimalControl\nOrdinaryDiffEq\nPlots\nRoots\nSymbolics\n\nList of all the exported names:\n\nModel\nSynthesis\navailable_methods\ncheck_root\nplot\nsolution\n\n\n\n\n\n","category":"module"},{"location":"api-filtration.html#Filtration.Model","page":"API","title":"Filtration.Model","text":"Type of a Model model, composed by:\n\ne₊ : the function e_+(x_1)\ne₋ : the function e_-(x_1)\nf₊ : the function f_+(x_1)\nf₋ : the function f_-(x_1)\ng₊ : the function g_+(x_1)\ng₋ : the function g_-(x_1)\ncriteria_type : the criteria type, either :min or :max\nλ₀ : the constant associated to the criteria type\ndynamics! : the cost and state dynamics function\nde₊ : the function e_+(x_1), compute thanks to ForwardDiff package\nde₋ : the function e_-(x_1), compute thanks to ForwardDiff package\ndf₊ : the function f_+(x_1), compute thanks to ForwardDiff package\ndf₋ : the function f_-(x_1), compute thanks to ForwardDiff package\ndg₊ : the function g_+(x_1), compute thanks to ForwardDiff package\ndg₋ : the function g_-(x_1), compute thanks to ForwardDiff package\nxₛ : the singular state x_s\nuₛ : the singular control u_s\nΔx₂ : the value Delta_x = x_f - x_2(T), where T is the final time to leave the singular arc\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Model-Tuple{Function, Function, Function, Function, Function, Function, Symbol}","page":"API","title":"Filtration.Model","text":"Model(\n    e₊::Function,\n    e₋::Function,\n    f₊::Function,\n    f₋::Function,\n    g₊::Function,\n    g₋::Function,\n    criteria_type::Symbol;\n    initial_guess\n) -> Model\n\n\nConstructor for Model. \n\nArguments\n\ne₊ : the function e_+(x₁)\ne₋ : the function e_-(x₁)\nf₊ : the function f_+(x₁)\nf₋ : the function f_-(x₁)\ng₊ : the function g_+(x₁)\ng₋ : the function g_-(x₁)\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for the singular state x_s, initialized to 1.\n\nReturns\n\nmodel : the Model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Model-Tuple{Function, Function, Function, Function, Symbol}","page":"API","title":"Filtration.Model","text":"Model(\n    e₊::Function,\n    e₋::Function,\n    f₊::Function,\n    f₋::Function,\n    criteria_type::Symbol;\n    initial_guess\n) -> Model\n\n\nConstructor for Model structure. \n\nnote: Note\nThis function is a wrapper of Model function, where the functions g_+ and g_- are set to 0 and 1 functions, respectively. This leads to dot x_2 = 1 with x_2(t_0) = 0, ie. x_2(t) = t.\n\nArguments\n\ne₊ : the function e_+(x_1)\ne₋ : the function e_-(x_1)\nf₊ : the function f_+(x_1)\nf₋ : the function f_-(x_1)\ncriteria_type : the criteria type, either :min or :max`\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for the singular state x_s, initialized to 1.\n\nReturns\n\nmodel : the Model model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Synthesis","page":"API","title":"Filtration.Synthesis","text":"Type of a optimal synthesis, composed by:\n\nmodel : a Model\ntlim : the limits of time t\nxlim : the limits of mass m\nmethod : method use to compute the switching locus and the dispersial locus curve. See DL_available_methods for the list of available methods\ncut₋ : the cut₋ function\ncut₊ : the cut₊ function\nSL : the switching locus\nDL : the dispersial locus\nend_SL : end of the switching locus curve \n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Synthesis-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.Synthesis","text":"Synthesis(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real};\n    method\n) -> Synthesis\n\n\nConstructor for Synthesis structure. \n\nArguments\n\nmodel : a Model\nxlim : the limits of x-axis, which corresponds to the x_2 state\nylim : the limits of y-axis, which corresponds to the x_1 state\n\nKeyword arguments (optional)\n\nmethod : method used to compute the dispersial locus curve, initialized to :continuation. See DL_available_methods for the list of available methods\n\nReturns\n\nsynthesis : the Synthesis\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.available_methods-Tuple{}","page":"API","title":"Filtration.available_methods","text":"available_methods() -> Tuple{Symbol, Symbol}\n\n\nReturn the list of available methods to compute the switching locus and the dispersial locus functions.\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.check_root-Tuple{Function, Function, Function, Function, Function, Function, Symbol}","page":"API","title":"Filtration.check_root","text":"check_root(\n    e₊::Function,\n    e₋::Function,\n    f₊::Function,\n    f₋::Function,\n    g₊::Function,\n    g₋::Function,\n    criteria_type::Symbol;\n    xlim\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the Model type. \n\nArguments\n\ne₊ : the function e_+(x_1)\ne₋ : the function e_-(x_1)\nf₊ : the function f_+(x_1)\nf₋ : the function f_-(x_1)\ng₊ : the function g_+(x_1)\ng₋ : the function g_-(x_1)\n\nKeyword arguments (optional)\n\nxlim : limits for x axis, initialized to (0,10)\n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.check_root-Tuple{Function, Function, Function, Function, Symbol}","page":"API","title":"Filtration.check_root","text":"check_root(\n    e₊::Function,\n    e₋::Function,\n    f₊::Function,\n    f₋::Function,\n    criteria_type::Symbol;\n    xlim\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the Model type. \n\nnote: Note\nThis function is a wrapper of check_root function, where the functions g_+ and g_- are set to 0 and 1 functions, respectively.\n\nArguments\n\ne₊ : the function f_+(x_1)\ne₋ : the function f_-(x_1)\nf₊ : the function g_+(x_1)\nf₋ : the function g_-(x_1)\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\nxlim : limits for x axis, initialized to (0,10)\n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solution-Tuple{Synthesis, Real, Real, Real}","page":"API","title":"Filtration.solution","text":"solution(\n    synthesis::Synthesis,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> SciMLBase.ODESolution\n\n\nWrapper to get solution from synthesis. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Synthesis}","page":"API","title":"RecipesBase.plot","text":"plot(\n    s::Synthesis;\n    cut_neg_nb_points,\n    cut_pos_nb_points,\n    SL_nb_points,\n    DL_nb_points,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Synthesis.\n\nArguments\n\nsynthesis : a Synthesis\n\nKeyword arguments (optional)\n\ncut_neg_nb_points : number of points to show the cut₋ curve, initialized to nothing (use the points given by the ODESolution)\ncut_pos_nb_points : number of points to show the cut₊ curve, initialized to nothing (use the points given by the ODESolution)\nSL_nb_points : number of points computed for the switching locus curve, initialized to nothing (use the points given by the ODESolution if synthesis.method = :continuation or 10 points if synthesis.method = :direct)\nDL_nb_points : number of points computed for the dispersial locus curve, initialized to nothing (use the points given by the ODESolution if synthesis.method = :continuation or 10 points if synthesis.method = :direct)\nkwargs... : keyword arguments for plot \n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"}]
}
