var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Cited-References","page":"References","title":"Cited References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"The following references are cited in the documentation.","category":"page"},{"location":"references.html","page":"References","title":"References","text":"F. Aichouche, N. Kalboussi, A. Rapaport, J. Harmand (2020). Modeling and optimal control for production-regeneration systems - preliminary results -, 2020 European Control Conference (ECC)\nB. Benyahia, A. Charfi, N. Benamar, M. Heran, A. Grasmick, B. Cherki, J. Harmand (2013). A simple model of anaerobic membrane bioreactor for control design: coupling the “AM2b” model with a simple membrane fouling dynamics, World Congress on Anerobic Digestion: Recovering (bio) Ressources for the World\nN.G. Cogan, S. Chellam (2014) A method for determining the optimal back-washing frequency and duration for dead-end microfiltration, Journal of Membrane Science\nN.G. Cogan, J. Li, A. R. Badireddy, S. Chellam (2016) Optimal backwashing in dead-end bacterial microfiltration with irreversible attachment mediated by extracellular polymeric substances production, Journal of Membrane Science\nF. Ellouze, Y. Kammoun, N. Kalboussi, A. Rapaport, J. Harmand, S. Nasr, N. Ben Amar (2023) Optimal control of backwash scheduling for pumping energy saving: Application to the treatment of urban wastewater, Journal of Water Process Engineering","category":"page"},{"location":"references.html","page":"References","title":"References","text":"N. Kalboussi, A. Rapaport, T. Bayen, N. Ben Amar, F. Ellouze, J. Harmand (2017) Optimal control of a membrane filtration system, IFAC-PapersOnLine\nN. Kalboussi, J. Harmand, A. Rapaport, T. Bayen, F. Ellouze, N. Ben Amar (2018) Optimal control of physical backwash strategy - towards the enhancement of membrane filtration process performance, Journal of Membrane Science","category":"page"},{"location":"dev-filtration.html#dev-filtration","page":"Developpers","title":"Filtration.jl private functions","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-filtration.html#Index","page":"Developpers","title":"Index","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Pages   = [\"dev-filtration.md\"]\nModules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-filtration.html#Documentation","page":"Developpers","title":"Documentation","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Modules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Filtration\nusing Plots","category":"page"},{"location":"examples.html#Max-volume-case","page":"Examples","title":"Max volume case","text":"","category":"section"},{"location":"examples.html#Benyahia-et-al.,-2013","page":"Examples","title":"Benyahia et al., 2013","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Benyahia et al., 2013] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,10); mlim = (0,10)\na = 1; b = 1; e = 1\nf₁(m) = b / (e + m)\nf₂(m) = a * m\ng(m)  = 1 / (e + m)\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = g(m)\ng₋(m) = 0\n\nmodel = MaxVolume(f₊, f₋, g₊, g₋)\nplot_synthesis(model, tlim, mlim)","category":"page"},{"location":"examples.html#Cogan-Chellamb,-2014","page":"Examples","title":"Cogan Chellamb, 2014","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Cogan and Chellamb, 2014] and [Cogan and al., 2016] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,40); mlim = (0,10)\na = 1; b = 1; e = 1\n\nf₁(m) = b ./ (e .+ m)\nf₂(m) = (a .* m) ./ (e .+ m)\ng(m) = 1 ./ (e .+ m)\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = g(m)\ng₋(m) = 0\n\nmodel = MaxVolume(f₊, f₋, g₊, g₋)\nplot_synthesis(model, tlim, mlim)","category":"page"},{"location":"examples.html#Kalboussi-et-al.,-2018","page":"Examples","title":"Kalboussi et al., 2018","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Kalboussi et al., 2018] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0, 0.25); mlim = (0,10)\na₁ = 91.7; a₂ = 0.64; b = 490.07; d = 4125.6; e = 18.06\n\nf₁(m) = b ./ (e .+ m)\nf₂(m) = a₁ .* m\ng₁(m) = d ./ (e.+ m)\ng₂(m) = a₁ ./ a₂\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = 0.5*(g₁(m) + g₂(m))\ng₋(m) = 0.5*(g₁(m) - g₂(m))\n\nmodel = MaxVolume(f₊, f₋, g₊, g₋)\nplot_synthesis(model, tlim, mlim)","category":"page"},{"location":"examples.html#Min-energy-example","page":"Examples","title":"Min energy example","text":"","category":"section"},{"location":"examples.html#Aiouche-et-al.,-2020","page":"Examples","title":"Aiouche et al., 2020","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Aiouche et al., 2020] : ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0,50); mlim = (0,80)\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\n\nfp(m) = -ap*m + bp\nfr(m) = ar*m\nlp(m) = cp*m + dp\nlr(m) = cr*m + dr\n\nf₊(m) = 0.5*(fp(m) + fr(m))\nf₋(m) = 0.5*(fp(m) - fr(m))\ng₊(m) = 0.5*(Qp + Qr)\ng₋(m) = 0.5*(Qp - Qr)\ne₋(m) = 0.5*(lp(m) + lr(m))\ne₊(m) = 0.5*(lp(m) - lr(m))\n\nmodel = MinEnergy(f₊, f₋, g₊, g₋, e₊, e₋; mₛ_guess = 20.)\nplt = plot_synthesis(model, vlim, mlim)","category":"page"},{"location":"examples.html#Ellouze-et-al.,-2023","page":"Examples","title":"Ellouze et al., 2023","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Ellouze et al., 2023] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0, 0.04); mlim = (0, 0.05)\nJv = 2.71e-6; JBW = 5.66e-6; TMP01 = 7892.4; Rm = 1.79e12\nC = 2184e-3; β = 1e-6; α = 2.02e14; η = 4.9e-3\nk1f = 2.0769; k2f = 0.0185; k1BW = 9.0551; k2BW = 0.0870\n\nff(m) = C*Jv - C*Jv*β*m\nfBW(m) = -η*m\nEf(m) = k1f * m + k2f \nEBW(m) = k1BW * m + k2BW\n\nf₊(m) = 0.5*(ff(m) - fBW(m))\nf₋(m) = 0.5*(ff(m) + fBW(m))\ng₊(m) = 0.5*(Jv + JBW)\ng₋(m) = 0.5*(Jv - JBW)\ne₊(m) = 0.5*(Ef(m) - EBW(m))\ne₋(m) = 0.5*(Ef(m) + EBW(m))\n\nmodel = MinEnergy(f₊, f₋, g₊, g₋, e₊, e₋)\nplot_synthesis(model, vlim, mlim)","category":"page"},{"location":"basic-usage.html#Basic-usage","page":"Basic Usage","title":"Basic usage","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The goal of the Filtration.jl package is to provide optimal systesis and optimal solution for some classes of optimal control problems which can be found for optimal control of membrane filtration process. The two classes of problems are corresponds to the max volume and the min energy case. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThe provided function given by Filtration.jl package can work whatever the inputs functions are. However, we need to be sure that there exists solutions for this kind of problems and that there exist exacly one root on the domain of interest of a function given by ...","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Here is the used package to run this page. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"using Filtration\nusing Plots\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Max-volume-case","page":"Basic Usage","title":"Max volume case","text":"","category":"section"},{"location":"basic-usage.html#General-description","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Let us consider the membrane filtration process where the goal is to maximize the water net production ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    max_x(cdot) u(cdot) int_t_0^t_f g_+(m(t)) u(t) + g_-(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = f_+(m(t)) u(t) + f_-(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"with the initial condition m(0) = m_0 and where the initial time t_0 and the final time t_f are fixed. ","category":"page"},{"location":"basic-usage.html#Example","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Benyahia et al., 2013] model, where the functions are defined on the following code section. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the plot_max_volume function to ensure that there exsit a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"a = 1; b = 1; e = 1;\nf₁(m) = b / (e + m)\nf₂(m) = a * m\ng(m)  = 1 / (e + m)\n\nf₊(m) = 0.5*(f₁(m) + f₂(m))\nf₋(m) = 0.5*(f₁(m) - f₂(m))\ng₊(m) = g(m)\ng₋(m) = 0\n\nplot_max_volume(f₊, f₋, g₊, g₋)","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the MaxVolume model. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = MaxVolume(f₊, f₋, g₊, g₋, mₛ_guess = 2)\nnothing # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be plot thanks to the optimal_synthesis function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"tlim = (0,10); mlim = (0,10)\nplt = plot_synthesis(model, tlim, mlim)","category":"page"},{"location":"basic-usage.html#Automatic-indirect-solve","page":"Basic Usage","title":"Automatic indirect solve","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function indirect_solve provide the optimal trajectory by indirect method, as an ODESolution. We can easily add some optimal state trajectories on the optimal synthesis plot.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"for m0 ∈ range(mlim[1], mlim[2])\n    sol = indirect_solve(model, tlim[1], tlim[2], m0)\n    t = sol.t\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nfor t0 ∈ range(tlim[1], tlim[2])\n    sol = indirect_solve(model, t0, tlim[2], mlim[1])\n    t = sol.t\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nfor t0 ∈ range(tlim[1], 7.5, 10)\n    sol = indirect_solve(model, t0, tlim[2], mlim[2])\n    t = sol.t\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nplt","category":"page"},{"location":"basic-usage.html#Min-Energy-case","page":"Basic Usage","title":"Min Energy case","text":"","category":"section"},{"location":"basic-usage.html#General-description-2","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can also consider another case where the goal is to minimize the energy ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    min_x(cdot) u(cdot) t_f int_t_0^t_f e_+(m(t)) u(t) + e_-(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = f_+(m(t)) u(t) + f_-(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We also want to obtain a final volume v(t_f) = v_f of water at the final time t_f. The dynamic of the state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot v(t) = g_+(m(t)) u(t) + g_-(m(t)) quad t in t_0 t_f ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The initial time t_0 is fixed but the final time t_f is free. ","category":"page"},{"location":"basic-usage.html#Example-2","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Aiouche et al., 2020] model, where the functions are defined on the following code section.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the plot_min_energy function to ensure that there exsit a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"ap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\nfp(m) = -ap*m + bp\nfr(m) = ar*m\nlp(m) = cp*m + dp\nlr(m) = cr*m + dr\n\nf₊(m) = 0.5*(fp(m) + fr(m))\nf₋(m) = 0.5*(fp(m) - fr(m))\ng₊(m) = 0.5*(Qp + Qr)\ng₋(m) = 0.5*(Qp - Qr)\ne₋(m) = 0.5*(lp(m) + lr(m))\ne₊(m) = 0.5*(lp(m) - lr(m))\n\nplot_min_energy(f₊, f₋, g₊, g₋, e₊, e₋; xlim = (0, 30))","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the MinEnergy model. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = MinEnergy(f₊, f₋, g₊, g₋, e₊, e₋; mₛ_guess = 20.)\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis-2","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be plot thanks to the optimal_synthesis function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"vlim = (0,50); mlim = (0,50)\nplt = plot_synthesis(model, vlim, mlim)","category":"page"},{"location":"basic-usage.html#Automatic-indirect-solve-2","page":"Basic Usage","title":"Automatic indirect solve","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function indirect_solve provide the optimal trajectory by indirect method, as an ODESolution. We can easily add some optimal state trajectories on the optimal synthesis plot.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"for m0 ∈ range(mlim[1], mlim[2], 10)\n    sol = indirect_solve(model, vlim[1], vlim[2], m0)\n    v = [x[3] for x ∈ sol.u]\n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, v, m, color = :Gray, label = \"\")\nend\nfor v0 ∈ range(vlim[1], vlim[2], 10)\n    sol = indirect_solve(model, v0, vlim[2], mlim[1])\n    v = [x[3] for x ∈ sol.u] \n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, v, m, color = :Gray, label = \"\")\nend\nfor v0 ∈ range(vlim[1], 30, 7)\n    sol = indirect_solve(model, v0, vlim[2], mlim[2])\n    v = [x[3] for x ∈ sol.u] \n    m = [x[2] for x ∈ sol.u]\n    plot!(plt, v, m, color = :Gray, label = \"\")\nend\nplt","category":"page"},{"location":"index.html#Filtration-Package","page":"Introduction","title":"Filtration Package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Filtration.jl package.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"},{"location":"api-filtration.html#Filtration.jl-API","page":"API","title":"Filtration.jl API","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-filtration.html","page":"API","title":"API","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-filtration.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Pages   = [\"api-filtration.md\"]\nModules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-filtration.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Modules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-filtration.html#Filtration.Filtration","page":"API","title":"Filtration.Filtration","text":"Filtration module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataInterpolations\nDocStringExtensions\nFiniteDifferences\nForwardDiff\nLaTeXStrings\nMINPACK\nNemo\nOptimalControl\nOrdinaryDiffEq\nPlots\nRoots\nSymbolics\n\nList of all the exported names:\n\nMaxVolume\nMinEnergy\ncuts\ndispersial_locus\nend_switching_locus\nindirect_solve\nindirect_solve_MP\nindirect_solve_MSP\nindirect_solve_P\nindirect_solve_PSP\nplot_max_volume\nplot_min_energy\nplot_synthesis\nswitching_locus\n\n\n\n\n\n","category":"module"},{"location":"api-filtration.html#Filtration.MaxVolume","page":"API","title":"Filtration.MaxVolume","text":"Type of a MaxVolume model, composed by:\n\nf₊ : the function f_+(m)\nf₋ : the function f_-(m)\ng₊ : the function g_+(m)\ng₋ : the function g_-(m)\ndynamics : the cost and state dynamics function\ndynamics! : the cost and state dynamics function\ndf₊ : the function f_+(m), compute thanks to ForwardDiff package\ndf₋ : the function f_-(m), compute thanks to ForwardDiff package\ndg₊ : the function g_+(m), compute thanks to ForwardDiff package\ndg₋ : the function g_-(m), compute thanks to ForwardDiff package\nmₛ : the singular state m_s\nuₛ : the singular control u_s\nλₛ : the singular costate lambda_s\nΔt : the value Delta t = t_f - T, where T is the final time to leave the singular arc\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.MaxVolume-NTuple{4, Function}","page":"API","title":"Filtration.MaxVolume","text":"MaxVolume(\n    f₊::Function,\n    f₋::Function,\n    g₊::Function,\n    g₋::Function;\n    mₛ_guess\n) -> MaxVolume\n\n\nConstructor for MaxVolume structure. \n\nArguments\n\nf₊ : the function f_+(m)\nf₋ : the function f_-(m)\ng₊ : the function g_+(m)\ng₋ : the function g_-(m)\nmₛguess : initial guess for the singular state ``ms``, initialized to  0.5\n\nReturns\n\nmodel : the MaxVolume model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.MinEnergy","page":"API","title":"Filtration.MinEnergy","text":"Type of a MinEnergy model, composed by:\n\nf₊ : the function f_+(m)\nf₋ : the function f_-(m)\ng₊ : the function g_+(m)\ng₋ : the function g_-(m)\ne₊ : the function e_+(m)\ne₋ : the function e_-(m)\ndynamics : the cost and state dynamics function\ndynamics! : the cost and state dynamics function\ndf₊ : the function f_+(m), compute thanks to ForwardDiff package\ndf₋ : the function f_-(m), compute thanks to ForwardDiff package\ndg₊ : the function g_+(m), compute thanks to ForwardDiff package\ndg₋ : the function g_-(m), compute thanks to ForwardDiff package\nde₊ : the function e_+(m), compute thanks to ForwardDiff package\nde₋ : the function e_-(m), compute thanks to ForwardDiff package\nmₛ : the singular state m_s\nuₛ : the singular control u_s\nλₘₛ : the singular costate lambda_ms associated to the state m\nλᵥ : the constant costate lambda_v associated to the state v\nΔv : the value Delta_v = v_f - v(T), where T is the final time to leave the singular arc\nΔt : the value Delta t = t_f - T, where T is the final time to leave the singular arc\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.MinEnergy-NTuple{6, Function}","page":"API","title":"Filtration.MinEnergy","text":"MinEnergy(\n    f₊::Function,\n    f₋::Function,\n    g₊::Function,\n    g₋::Function,\n    e₊::Function,\n    e₋::Function;\n    mₛ_guess\n) -> MinEnergy\n\n\nConstructor for MinEnergy structure. \n\nArguments\n\nf₊ : the function f_+(m)\nf₋ : the function f_-(m)\ng₊ : the function g_+(m)\ng₋ : the function g_-(m)\ne₊ : the function e_+(m)\ne₋ : the function e_-(m)\n\nReturns\n\nmodel : the MinEnergy model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.cuts-Tuple{MaxVolume, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.cuts","text":"cuts(\n    model::MaxVolume,\n    tlim::Tuple{Real, Real},\n    mlim::Tuple{Real, Real}\n) -> Tuple{Any, Any}\n\n\nCompute the cuts m_-(t) and m_+(t), which corresponds to the curves which leads to m_s at time T. The function m is the solution on 0 T of\n\nleftbeginarrayll\n    dot v = g_-(m) - g_+(m)  quad v(T) = 0 dot m = f_-(m) - f_+(m)  quad m(T) = m_s\nendarray right\n\nand the function m is the solution on 0 T of \n\nleftbeginarrayll\n    dot v = g_-(m) + g_+(m)  quad v(T) = 0  dot m = f_-(m) + f_+(m)  quad m(T) = m_s\nendarray right\n\nwhere T = t_f - Delta t corresponds to the optimal time to exit the singular arc  and m_s the singular state.    \n\nwarning: Warning\nThe cost v(T) at the initial time T is initialized to 0. \n\nArguments\n\nmodel : a MaxVolume\ntlim : tuple of real which corresponds to the limits of time t\nmlim : tuple of real which corresponds to the limits of mass m\n\nReturns\n\ncut₋ : the function m_-, as an ODESolution\ncut₊ : the function m_+, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.cuts-Tuple{MinEnergy, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.cuts","text":"cuts(\n    model::MinEnergy,\n    vlim::Tuple{Real, Real},\n    mlim::Tuple{Real, Real}\n) -> Tuple{Any, Any}\n\n\nCompute the cuts m_-(t) and m_+(t), which corresponds to the curves which leads to m_s at time T. The function m is the solution on T tf of\n\nleft beginarrayll\n    dot e = e_-(m) - e_+(m)  quad e(T) = 0 dot m = f_-(m) - f_+(m)  quad m(T) = m_s dot v = g_-(m) - g_+(m)  quad v(T) = v_T\nendarray right\n\nand the function m is the solution on T tf of \n\nleftbeginarrayll\n    dot e = e_-(m) + e_+(m)  quad e(T) = 0 dot m = f_-(m) + f_+(m)  quad m(T) = m_s dot v = g_-(m) + g_+(m)  quad v(T) = v_T\nendarray right\n\nwhere T = t_f - Delta t corresponds to the optimal time to exit the singular arc, v_T = v_f - Delta_v the associated state v and m_s the singular state.   \n\nwarning: Warning\nThe cost e(T) at time T is initialized to 0. \n\nArguments\n\nmodel : a MinEnergy\nvlim : tuple of real which corresponds to the limits of volume v\nmlim : tuple of real which corresponds to the limits of mass m \n\nReturns\n\ncut₋ : the function m_-, as an ODESolution\ncut₊ : the function m_+, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.dispersial_locus-Tuple{Real, MaxVolume, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.dispersial_locus","text":"dispersial_locus(\n    t::Real,\n    model::MaxVolume,\n    tlim::Tuple{Real, Real},\n    mlim::Tuple{Real, Real};\n    m_guess\n) -> Float64\n\n\nCompute some points of the dispersial locus curve, which corresponds to the curve where the cost associated to u₋ ∘ u₊ is equal to the cost associated to u₊. \n\nwarning: Warning\nThis function must be used only when a dispersial locus happened, ie. when the switching locus don't hit the bounds. \n\nArguments\n\nmodel : a MaxVolume\ntlim : tuple of real which corresponds to the limits of time t\nmlim : tuple of real which corresponds to the limits of mass m\nSL : an ODESolution which corresponds to the switching locus computed by switching_locus function\n\nReturns\n\ntspan_DL : array of time t\nmspan_DL : array of state m \n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.dispersial_locus-Tuple{Real, MinEnergy, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.dispersial_locus","text":"dispersial_locus(\n    m::Real,\n    model::MinEnergy,\n    vlim::Tuple{Real, Real},\n    mlim::Tuple{Real, Real}\n) -> Any\n\n\nDispersial locus function, which gives the volume v from a mass m, which corresponds to the curve where the cost associated to u₋ ∘ u₊ is equal to the cost associated to u₊. \n\nwarning: Warning\nThis function must be used only when a dispersial locus happened, ie. when the end of the switching curve (given by the end_switching_locus function) is below the maximal bound of m. \n\nArguments\n\nm : the mass m\nmodel : a MinEnergy\nvlim : tuple of real which corresponds to the limits of volume v\nReturn\n\nv : the volume v\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.end_switching_locus-Tuple{MinEnergy, Tuple{Real, Real}}","page":"API","title":"Filtration.end_switching_locus","text":"end_switching_locus(\n    model::MinEnergy,\n    vlim::Tuple{Real, Real};\n    m_guess\n) -> Any\n\n\nCompute the mass m which corresponds to the end of the switching locus. \n\nDenoting SL the switching locus function, this end point m is given by finding a root of \n\n    SL(m) * (f(m) - f(m)) - (g(m) - g(m))\n\nSince a rootfinding function is used in the computation of the switching locus function, the derivative of SL is computed by finite differences method, thanks to the FiniteDifferences package. \n\nArguments\n\nmodel: a MinEnergy\nvlim : tuple of real which corresponds to the limits of volume v\nmguess : initial guess for m, initialized to the singular state ``ms`` if not provided\n\nReturn\n\nm : the limit mass m\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve-Tuple{MaxVolume, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve","text":"indirect_solve(\n    model::MaxVolume,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MaxVolume model by indirect shooting.\n\nArguments\n\nmodel : a MaxVolume\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve-Tuple{MinEnergy, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve","text":"indirect_solve(\n    model::MinEnergy,\n    v0::Real,\n    vf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MinEnergy model by indirect shooting.\n\nArguments\n\nmodel : a MinEnergy\nv0 : the initial volume v_0\nvf : the final volume v_f\nm0 : the initial state m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_MP-Tuple{MaxVolume, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_MP","text":"indirect_solve_MP(\n    model::MaxVolume,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MaxVolume model by indirect method, with the structure given by u_- circ u_+, and when the change is done by intersection with the switching curve\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead. \n\nArguments\n\nmodel : a MaxVolume\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_MP-Tuple{MinEnergy, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_MP","text":"indirect_solve_MP(\n    model::MinEnergy,\n    v0::Real,\n    vf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MinEnergy model by indirect method, with the structure given by u_- circ u_+, and when the change is done by intersection with the switching curve\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead. \n\nArguments\n\nmodel : a MinEnergy\nv0 : the initial volume v_0\nvf : the final volume v_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_MSP-Tuple{MaxVolume, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_MSP","text":"indirect_solve_MSP(\n    model::MaxVolume,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MaxVolume model, with the structure given by u_- circ u_s circ u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead. \n\nArguments\n\nmodel : a MaxVolume\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_MSP-Tuple{MinEnergy, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_MSP","text":"indirect_solve_MSP(\n    model::MinEnergy,\n    v0::Real,\n    vf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MinEnergy model, with the structure given by u_- circ u_s circ u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead. \n\nArguments\n\nmodel : a MinEnergy\nv0 : the initial volume v_0\nvf : the final volume v_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_P-Tuple{MaxVolume, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_P","text":"indirect_solve_P(\n    model::MaxVolume,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MaxVolume model, with the structure given by u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead. \n\nArguments\n\nmodel : a MaxVolume\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_P-Tuple{MinEnergy, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_P","text":"indirect_solve_P(\n    model::MinEnergy,\n    v0::Real,\n    vf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MinEnergy model, with the structure given by u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead. \n\nArguments\n\nmodel : a MinEnergy\nv0 : the initial volume v_0\nvf : the final volume v_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_PSP-Tuple{MaxVolume, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_PSP","text":"indirect_solve_PSP(\n    model::MaxVolume,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to a MaxVolume model by indirect shooting, with the structure given by u_+ circ u_s circ u_+\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead. \n\nArguments\n\nmodel : a MaxVolume\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial mass m_0\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve_PSP-Tuple{MinEnergy, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve_PSP","text":"indirect_solve_PSP(\n    model::MinEnergy,\n    v0::Real,\n    vf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting,  with the structure given by u_+ circ u_s circ u_+\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use indirect_solve function instead.  \n\nArguments\n\nmodel : a MinEnergy\nv0 : the initial volume v_0\nvf : the final volume v_f\nm0 : the initial mass m_0 \n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.plot_max_volume-NTuple{4, Function}","page":"API","title":"Filtration.plot_max_volume","text":"plot_max_volume(\n    f₊::Function,\n    f₋::Function,\n    g₊::Function,\n    g₋::Function;\n    xlim\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the MaxVolume type. \n\nArguments\n\nf₊ : the function f_+(m)\nf₋ : the function f_-(m)\ng₊ : the function g_+(m)\ng₋ : the function g_-(m)\nxlim : limits for x axis, initialized to (0,10)\n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.plot_min_energy-NTuple{6, Function}","page":"API","title":"Filtration.plot_min_energy","text":"plot_min_energy(\n    f₊::Function,\n    f₋::Function,\n    g₊::Function,\n    g₋::Function,\n    e₊::Function,\n    e₋::Function;\n    xlim\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the MinEnergy type. \n\nArguments\n\nf₊ : the function f_+(m)\nf₋ : the function f_-(m)\ng₊ : the function g_+(m)\ng₋ : the function g_-(m)\ne₊ : the function e_+(m)\ne₋ : the function e_-(m)\nxlim : limits for x axis, initialized to (0,10)\n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.plot_synthesis-Tuple{MaxVolume, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.plot_synthesis","text":"plot_synthesis(\n    model::MaxVolume,\n    tlim::Tuple{Real, Real},\n    mlim::Tuple{Real, Real};\n    DL_nb_points\n) -> Plots.Plot\n\n\nPlot the optimal synthesis of a MaxVolume.\n\nArguments\n\nmodel : a MaxVolume\ntlim : tuple of real which corresponds to the limits of time t\nmlim : tuple of real which corresponds to the limits of mass m\nDLnbpoints : number of points computed for the dispersial locus curve, initialized to 10\n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.plot_synthesis-Tuple{MinEnergy, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.plot_synthesis","text":"plot_synthesis(\n    model::MinEnergy,\n    vlim::Tuple{Real, Real},\n    mlim::Tuple{Real, Real};\n    SL_nb_points,\n    DL_nb_points\n) -> Plots.Plot\n\n\nPlot the optimal synthesis of a MinEnergy.\n\nArguments\n\nmodel : a MinEnergy\nvlim : tuple of real which corresponds to the limits of time v\nmlim : tuple of real which corresponds to the limits of mass m\nSLnbpoints : number of points computed for the switching locus curve, initialized to 10\nDLnbpoints : number of points computed for the dispersial locus curve, initialized to 10\n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.switching_locus-Tuple{MaxVolume, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.switching_locus","text":"switching_locus(\n    model::MaxVolume,\n    tlim::Tuple{Real, Real},\n    mlim::Tuple{Real, Real}\n) -> Any\n\n\nCompute the switching locus S(m) which give the time with respect to the deposit mass m. This function is the solution of \n\nS(m) = frac1f_+(m) + f_-(m) - frac gamma(m)tilde g(m_T(m)) (f_+(m_T(m)) + f_-(m_T(m))) quad S(mₛ) = T \n\nwhere \n\nbeginaligned\n    m_T(m)          = tilde g^-1(gamma(m)) tilde g(m)    = g_-(m) + g_+(m) gamma(m)      = - fracf_-(m) g_+(m)f_+(m) + g_-(m)\nendaligned\n\nand T = t_f - Delta t. The value of tilde g^-1(y) is numerically comute by solving tilde g(x) - y = 0. \n\nIn order to only compute the switching locus and not the dispersial one, the integration of the previous ODE stop when \n\nS(m) (f_-(m) - f_+(m)) - 1 = 0 \n\nThis condition can be handle thanks to the ContinuousCallback function of the OrdinaryDiffEq package. \n\nArguments\n\nmodel : a MaxVolume\ntlim : tuple of real which corresponds to the limits of time t\nmlim : tuple of real which corresponds to the limits of mass m\n\nReturns\n\nswitching_locus : the function S(m), as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.switching_locus-Tuple{Real, MinEnergy, Tuple{Real, Real}}","page":"API","title":"Filtration.switching_locus","text":"switching_locus(\n    m::Real,\n    model::MinEnergy,\n    vlim::Tuple{Real, Real};\n    m_guess\n) -> Any\n\n\nSwitching locus function, which gives the volume v from the mass m. \n\nFrom a given state m which belongs to this switching curve, the associated final state m_f is computed by finding a zero of \n\n    H(m m_f) = lambda_m(m m_f) (f_+(m) + f_-(m)) + lambda_v(m_f)(g_+(m) + g_-(m)) - (e_+(m) + e_-(m))\n\nwhere \n\n    lambda_m(m m_f) = frace_+(m) - lambda_v(m_f) g_+(m)f_+(m)\n\nand \n\n    lambda_v(m_f) =  frace_+(m) + e_-(m)g_+(m) + g_-(m) \n\nFrom this final state m_f, with the final volume v_f, the volume v is computed by a backward integration of the dynamic which stop when m(t) = m, thanks to a ContinuousCallback. \n\nwarning: Warning\nThe given state m must belong to the switching locus curve, ie. m_s leq m leq m_d where m_s is the singular state, given by model.mₛ, and where m_d is the end of the dispersial locus, computed by the end_switching_locus function.   \n\nArguments\n\nm : the mass m\nmodel : a MinEnergy\nvlim : tuple of real which corresponds to the limits of volume v\nmguess : initial guess for m, initialized to the singular state ``ms`` if not provided\n\nRetrun\n\nv : the volume v\n\n\n\n\n\n","category":"method"}]
}
