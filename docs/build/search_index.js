var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Cited-References","page":"References","title":"Cited References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"The following references are cited in the documentation.","category":"page"},{"location":"references.html","page":"References","title":"References","text":"F. Aichouche, N. Kalboussi, A. Rapaport, J. Harmand (2020). Modeling and optimal control for production-regeneration systems - preliminary results -, 2020 European Control Conference (ECC)\nB. Benyahia, A. Charfi, N. Benamar, M. Heran, A. Grasmick, B. Cherki, J. Harmand (2013). A simple model of anaerobic membrane bioreactor for control design: coupling the “AM2b” model with a simple membrane fouling dynamics, World Congress on Anerobic Digestion: Recovering (bio) Ressources for the World\nN.G. Cogan, S. Chellam (2014) A method for determining the optimal back-washing frequency and duration for dead-end microfiltration, Journal of Membrane Science\nN.G. Cogan, J. Li, A. R. Badireddy, S. Chellam (2016) Optimal backwashing in dead-end bacterial microfiltration with irreversible attachment mediated by extracellular polymeric substances production, Journal of Membrane Science\nF. Ellouze, Y. Kammoun, N. Kalboussi, A. Rapaport, J. Harmand, S. Nasr, N. Ben Amar (2023) Optimal control of backwash scheduling for pumping energy saving: Application to the treatment of urban wastewater, Journal of Water Process Engineering\nN. Kalboussi, A. Rapaport, T. Bayen, N. Ben Amar, F. Ellouze, J. Harmand (2017) Optimal control of a membrane filtration system, IFAC-PapersOnLine\nN. Kalboussi, J. Harmand, A. Rapaport, T. Bayen, F. Ellouze, N. Ben Amar (2018) Optimal control of physical backwash strategy - towards the enhancement of membrane filtration process performance, Journal of Membrane Science","category":"page"},{"location":"basic-usage.html#Basic-usage","page":"Basic Usage","title":"Basic usage","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The goal of the Filtration.jl package is to provide optimal systesis and optimal solution for a large classe of optimal control problems used for membrane filtration process. There exists mainly two formulation of such optimal control problem which can be found in the litterature.  ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThe provided function given by Filtration.jl package can work whatever the inputs functions are. However, we need to be sure that there exists solutions for this kind of problems and that there exist exacly one root on the domain of interest of a function given by the check_root function. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Here is the used packages to run this page. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"using Filtration\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Max-volume-case","page":"Basic Usage","title":"Max volume case","text":"","category":"section"},{"location":"basic-usage.html#General-description","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Let us consider the membrane filtration process where the goal is to maximize the water net production ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    max_x(cdot) u(cdot) int_t_0^t_f frac1+u(t)2 g_1(m(t))  + frac1-u(t)2 g_2(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = frac1+u(t)2 f_1(m(t)) + frac1-u(t)2 f_2(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"with the initial condition m(0) = m_0 and where the initial time t_0 and the final time t_f are fixed. ","category":"page"},{"location":"basic-usage.html#Example","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Benyahia et al., 2013] model, where the functions are defined on the following code section. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThe function 'check_root' and 'Model' need the functions of the model in inputs. The order of these functions is importants. We need to provide first the two function associated to the cost, and after the function(s) associated to the state(s). The (first) state corresponds to the state that is used on the dynamic of all functions. For the order of the couple of functions, we need to provide first the function that multiply the control u. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the check_root function to ensure that there exsit a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"a = 1; b = 1; e = 1;\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -p[1] * m\ng(m,p)  = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\ncheck_root(g₁, g₂, f₁, f₂, p, :max)","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the MaxVolume. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = Model(g₁, g₂, f₁, f₂, p, :max, initial_guess = 2.)\nnothing # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be constructed by the Synthesis function, and plot with the classical plot function","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"tlim = (0,10); mlim = (0,10)\nsynthesis = Synthesis(model, tlim, mlim)\nplt = plot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\", legend = :bottomright)","category":"page"},{"location":"basic-usage.html#Solution-trajectories","page":"Basic Usage","title":"Solution trajectories","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function solution extract from the synthesis the optimal trajectory. We can easily add some optimal state trajectories on the previous created plot, thanks to the add_solution_to_synthesis! function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"sol = solution(synthesis, tlim[1], tlim[2], 1)\nadd_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1], color = :gray)\nsol = solution(synthesis, tlim[1], tlim[2], 5)\nadd_solution_to_synthesis!(plt, sol, axis_arrow = :y, element = [1], color = :gray)\nfor t0 ∈ range(tlim[1], tlim[2])\n    sol = solution(synthesis, t0, tlim[2], mlim[1])\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1], color = :gray)\nend\nfor t0 ∈ range(tlim[1], synthesis.SL(synthesis.SL.t[end])[1], 10)\n    if t0 != synthesis.SL(synthesis.SL.t[end])[1]\n        sol = solution(synthesis, t0, tlim[2], mlim[2])\n        add_solution_to_synthesis!(plt, sol, axis_arrow = :y, element = [1], color = :gray)\n    end\nend\nfor m0 ∈ range(synthesis.SL.t[1], synthesis.SL.t[end], 10)\n    if m0 != synthesis.SL.t[end] && m0 != synthesis.SL.t[1]\n        t0 = synthesis.SL(m0)[1]\n        sol = solution(synthesis, t0, tlim[2], m0)\n        add_solution_to_synthesis!(plt, sol, axis_arrow = :x, color = :gray)\n    end\nend\nplt","category":"page"},{"location":"basic-usage.html#Min-Energy-case","page":"Basic Usage","title":"Min Energy case","text":"","category":"section"},{"location":"basic-usage.html#General-description-2","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can also consider another case where the goal is to minimize the energy ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    min_x(cdot) u(cdot) t_f int_t_0^t_f frac1+u(t)2 e_1(m(t)) + frac1-u(t)2 e_2(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = frac1+u(t)2 f_1(m(t)) + frac1-u(t)2 f_2(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We also want to obtain a final volume v(t_f) = v_f of water at the final time t_f. The dynamic of the state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot v(t) = frac1+u(t)2 g_1(m(t)) + frac1-u(t)2 g_2(m(t)) quad t in t_0 t_f ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The initial time t_0 is fixed but the final time t_f is free. ","category":"page"},{"location":"basic-usage.html#Example-2","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Aichouche et al., 2020] model, where the functions are defined on the following code section.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the check_root function to ensure that there exits a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"ap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) = -p[1]*m + p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\n\ncheck_root(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; xlim = (0, 30))","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the Model. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 20.)\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis-2","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be constructed by the Synthesis function, and plotted thanks to the Plot one. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"vlim = (0,50); mlim = (0,50)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\", legend = :bottomright)","category":"page"},{"location":"basic-usage.html#Solutions-trajectories","page":"Basic Usage","title":"Solutions trajectories","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function solution extract from the synthesis the optimal trajectory. We can easily add some optimal state trajectories on the previous created plot, thanks to the add_solution_to_synthesis! function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"add_solution_to_synthesis!(plt, solution(synthesis, vlim[1], vlim[2], mlim[2]), axis_arrow = :x, color = :gray)\nfor m0 ∈ range(mlim[1],model.xₛ, 5)\n    sol = solution(synthesis, vlim[1], vlim[2], m0)\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1], color = :gray)\nend\nfor v0 ∈ range(vlim[1],vlim[2], 10)\n    sol = solution(synthesis, v0, vlim[2], mlim[1])\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1], color = :gray)\nend\nfor v0 ∈ range(vlim[1],synthesis.SL.u[end][1], 10)\n    sol = solution(synthesis, v0, vlim[2], mlim[2])\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :y, element = [1], color = :gray)\nend\nfor m0 ∈ range(synthesis.SL.t[1], synthesis.SL.t[end], 5)\n    if m0 != synthesis.SL.t[end] && m0 != synthesis.SL.t[1]\n        t0 = synthesis.SL(m0)[1]\n        sol = solution(synthesis, t0, tlim[2], m0)\n        add_solution_to_synthesis!(plt, sol, axis_arrow = :x, color = :gray)\n    end\nend\nplt","category":"page"},{"location":"api-filtration.html#Filtration.jl-API","page":"API","title":"Filtration.jl API","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-filtration.html","page":"API","title":"API","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-filtration.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Pages   = [\"api-filtration.md\"]\nModules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-filtration.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Modules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-filtration.html#Filtration.Filtration","page":"API","title":"Filtration.Filtration","text":"Filtration module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDiffEqCallbacks\nDocStringExtensions\nForwardDiff\nIpopt\nLaTeXStrings\nOptimization\nOptimizationMOI\nOptimizationOptimJL\nOrdinaryDiffEq\nPlots\nRoots\n\nList of all the exported names:\n\nControl\nCostate\nExtremal\nModel\nMultiModel\nMultiSynthesis\nPareto\nSimulationModel\nSolution\nState\nSynthesis\nadd_solution_to_synthesis!\ncheck_root\ncompute_phi\nconstruct_extremal\ncontrol\ncostate\ncuts\ndispersal_locus\nfit\nplot\nplot!\nreal_solve\nshow\nsimulate\nsolution\nsolve\nsolve_MP\nsolve_MSP\nsolve_P\nsolve_PSP\nsolve_SP\nstate\nswitching_locus\n\n\n\n\n\n","category":"module"},{"location":"api-filtration.html#Filtration.Control","page":"API","title":"Filtration.Control","text":"Structure of a Control, composed by \n\ncontrol : a vector of functions\ntimes : a vector of times\nN : the number of intervals \nm : size of the control\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Control-Tuple{Real}","page":"API","title":"Filtration.Control","text":"Callable method for the Control structure. This return the value of the control at time t.\n\nArguments\n\nt : the time t\n\nReturn\n\nu : the value of the control u(t) at the time t\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Costate","page":"API","title":"Filtration.Costate","text":"Structure for a Costate, composed by\n\ncostate : a vector of ODESolution\ntime : a vector of times\nN : the number of intervals\nλ0 : the initial costate λ_0\nn : number of state / co-state\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Costate-Tuple{Real}","page":"API","title":"Filtration.Costate","text":"Callable method for the Costate structure. This return the value of the costate at time t.\n\nArguments\n\nt : the time t\n\nReturn\n\nx : the value of the costate lambda(t) at the time t\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Extremal","page":"API","title":"Filtration.Extremal","text":"Structure of a Solution, composed by \n\nstate : a State\ncostate : a Costate\ncontrol : a Control\ntime : a vector of times\nN : the number of intervals\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Model","page":"API","title":"Filtration.Model","text":"Structure of a Model, composed by:\n\ne₁ : the function e_1(x_1)\ne₁ : the function e_2(x_1)\nf₁ : the function f_1(x_1)\nf₂ : the function f_2(x_1)\ng₁ : the function g_1(x_1)\ng₂ : the function g_2(x_1)\ne₊ : the function e_+(x_1)\ne₋ : the function e_-(x_1)\nf₊ : the function f_+(x_1)\nf₋ : the function f_-(x_1)\ng₊ : the function g_+(x_1)\ng₋ : the function g_-(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\nλ₀ : the constant associated to the criteria type\ndynamics! : the cost and state dynamics function\nde₊ : the function e_+(x_1), compute thanks to ForwardDiff package\nde₋ : the function e_-(x_1), compute thanks to ForwardDiff package\ndf₊ : the function f_+(x_1), compute thanks to ForwardDiff package\ndf₋ : the function f_-(x_1), compute thanks to ForwardDiff package\ndg₊ : the function g_+(x_1), compute thanks to ForwardDiff package\ndg₋ : the function g_-(x_1), compute thanks to ForwardDiff package\nxₛ : the singular state x_s\nuₛ : the singular control u_s\nλ₁ₛ : the singular costate lambda_1s associated to the state x_1 \nλ₂ₛ : the singular costate lambda_2s associated to the state x_2\nΔx₂ : the value Delta_x = x_f - x_2(T), where T is the final time to leave the singular arc\nΔt : the difference between the final time and the time to leave the singular arc\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Model-Tuple{Function, Function, Function, Function, Function, Function, Vector{<:Real}, Symbol}","page":"API","title":"Filtration.Model","text":"Model(\n    e⁺::Function,\n    e⁻::Function,\n    f₊::Function,\n    f₋::Function,\n    g⁺::Function,\n    g⁻::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol;\n    initial_guess,\n    n,\n    m\n) -> Model\n\n\nConstructor for Model. \n\nArguments\n\ne₁ : the function e_1(x₁)\ne₂ : the function e_2(x₁)\nf₁ : the function f_1(x₁)\nf₂ : the function f_2(x₁)\ng₁ : the function g_1(x₁)\ng₂ : the function g_2(x₁)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for the singular state x_s, initialized to 1.\n\nReturns\n\nmodel : the Model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Model-Tuple{Function, Function, Function, Function, Vector{<:Real}, Symbol}","page":"API","title":"Filtration.Model","text":"Model(\n    e₊::Function,\n    e₋::Function,\n    f₊::Function,\n    f₋::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol;\n    initial_guess,\n    n,\n    m\n) -> Model\n\n\nConstructor for a Model. \n\nnote: Note\nThis function is a wrapper of Model function, where the functions g_1 and g_2 are set to 1. This leads to dot x_2 = 1 with x_2(t_0) = 0, ie. x_2(t) = t.\n\nArguments\n\ne₁ : the function e_1(x_1)\ne₂ : the function e_2(x_1)\nf₁ : the function f_1(x_1)\nf₂ : the function f_2(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max`\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for the singular state x_s, initialized to 1.\n\nReturns\n\nmodel : the Model model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.MultiModel","page":"API","title":"Filtration.MultiModel","text":"Structure of a MultiModel, composed by \n\nmodels : a vector of Models, which corresponds to turnpike\n__models : a vector of Models, which corresponds to anti-turnpike\nxₛ : vector of singular state value, which corresponds to turnpike\n__xₛ : vector of singular state value, which corresponds to anti-turnpike\nN : number of models\n__N : numbers of __models \n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.MultiModel-Tuple{Function, Function, Function, Function, Function, Function, Vector{<:Real}, Symbol, Vector{<:Real}}","page":"API","title":"Filtration.MultiModel","text":"MultiModel(\n    e₁::Function,\n    e₂::Function,\n    f₁::Function,\n    f₂::Function,\n    g₁::Function,\n    g₂::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol,\n    initial_guesses::Vector{<:Real}\n) -> MultiModel\n\n\nConstructor for MultiModel\n\nArguments\n\ne₁ : the function e_1(x₁)\ne₂ : the function e_2(x₁)\nf₁ : the function f_1(x₁)\nf₂ : the function f_2(x₁)\ng₁ : the function g_1(x₁)\ng₂ : the function g_2(x₁)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\ninitial_guesses : initial guesses for all singular states x_s\n\nReturns\n\nmultimodel : the MultiModel\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.MultiModel-Tuple{Function, Function, Function, Function, Vector{<:Real}, Symbol, Vector{<:Real}}","page":"API","title":"Filtration.MultiModel","text":"MultiModel(\n    e₁::Function,\n    e₂::Function,\n    f₁::Function,\n    f₂::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol,\n    initial_guesses::Vector{<:Real}\n) -> MultiModel\n\n\nConstructor for a MultiModel. \n\nnote: Note\nThis function is a wrapper of MultiModel function, where the functions g_1 and g_2 are set to 1. This leads to dot x_2 = 1 with x_2(t_0) = 0, ie. x_2(t) = t.\n\nArguments\n\ne₁ : the function e_1(x_1)\ne₂ : the function e_2(x_1)\nf₁ : the function f_1(x_1)\nf₂ : the function f_2(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max`\ninitial_guesses : initial guesses for all singular states x_s.\n\nKeyword arguments (optional)\n\nReturns\n\nmultimodel : the MultiModel\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.MultiSynthesis","page":"API","title":"Filtration.MultiSynthesis","text":"Structure of a MultiSynthesis, composed by \n\nsynthesis : the vector of Synthesis\nsep : a vector of ODESolution that connect synthesis\nN : number of Synthesis\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.MultiSynthesis-Tuple{MultiModel, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.MultiSynthesis","text":"MultiSynthesis(\n    multimodel::MultiModel,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> MultiSynthesis\n\n\nConstructor for MultiSynthesis\n\nArguments\n\nmultimodel : a MultiModel\nxlim : limits of x-axis\nylim : limits of y-axis\n\nReturn\n\nmultisynthesis : a MultiSynthesis\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Solution","page":"API","title":"Filtration.Solution","text":"Structure of a Solution, composed by \n\nstate : a State\ncontrol : a Control\ntime : a vector of times\nN : the number of intervals\nx0 : the initial state x(t_0) = x_0\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.State","page":"API","title":"Filtration.State","text":"Structure of a State, composed by \n\nstate : a vector of ODESolution\ntimes : a vector of times\nN : the number of intervals \nn : number of states\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.State-Tuple{Real}","page":"API","title":"Filtration.State","text":"Callable method for the State structure. This return the value of the state at time t.\n\nArguments\n\nt : the time t\n\nReturn\n\nx : the value of the state x(t) at the time t\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Synthesis","page":"API","title":"Filtration.Synthesis","text":"Structure of a optimal synthesis, composed by:\n\nmodel : a Model\nxlim : the limits of the x-axis\nylim : the limits of the y-axis\ncut₋ : the cut₋ function\ncut₊ : the cut₊ function\nSL : the switching locus\nDL : the dispersal locus with the switching locus\nDL2 : the dispersal locus with the singular curve\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Synthesis-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.Synthesis","text":"Synthesis(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> Synthesis\n\n\nConstructor of a Synthesis. \n\nArguments\n\nmodel : a Model\nxlim : the limits of x-axis\nylim : the limits of y-axis\n\nReturns\n\nsynthesis : the Synthesis\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, Control}","page":"API","title":"Base.show","text":"show(io::IO, z::Control)\n\n\nPrint a Control\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, Costate}","page":"API","title":"Base.show","text":"show(io::IO, z::Costate)\n\n\nPrint a Costate\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, Extremal}","page":"API","title":"Base.show","text":"show(io::IO, z::Extremal)\n\n\nPrint an Extremal\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, Model}","page":"API","title":"Base.show","text":"show(io::IO, z::Model)\n\n\nPrint a Model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, MultiModel}","page":"API","title":"Base.show","text":"show(io::IO, z::MultiModel)\n\n\nPrint a MultiModel\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, MultiSynthesis}","page":"API","title":"Base.show","text":"show(io::IO, z::MultiSynthesis)\n\n\nPrint a MultiSynthesis\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, Pareto}","page":"API","title":"Base.show","text":"show(io::IO, z::Pareto)\n\n\nPrint a Pareto\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, SimulationModel}","page":"API","title":"Base.show","text":"show(io::IO, z::SimulationModel)\n\n\nPrint a Model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, Solution}","page":"API","title":"Base.show","text":"show(io::IO, z::Solution)\n\n\nPrint a Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, State}","page":"API","title":"Base.show","text":"show(io::IO, z::State)\n\n\nPrint a State\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Base.show-Tuple{IO, Synthesis}","page":"API","title":"Base.show","text":"show(io::IO, z::Synthesis)\n\n\nPrint a Synthesis\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.add_solution_to_synthesis!-Tuple{Plots.Plot, Solution}","page":"API","title":"Filtration.add_solution_to_synthesis!","text":"add_solution_to_synthesis!(\n    plt::Plots.Plot,\n    solution::Solution;\n    element,\n    axis_arrow,\n    arrow,\n    color,\n    nb_pts,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nAdd a Solution to a synthesis plot. \n\nArguments\n\nplt : the synthesis plot\nsolution : the Solution\n\nKeyword arguments (optional)\n\nelement : list of index of solution.state to plot, initialized to [1, ..., solution.N]\n\n-axis_arrow: symbol to indicate the axis for the arrow, initialized to nothing (no arrow). This symbol must be :x or :y. \n\narrow : vector of axis_arrow coordinates to make arrows, initialized to empty\ncolor : color of trajectory, initialized to gray\nnb_pts : number of points for each sub-segments, initialized to 5\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.check_root-Tuple{Function, Function, Function, Function, Function, Function, Union{Nothing, Vector{<:Real}}, Symbol}","page":"API","title":"Filtration.check_root","text":"check_root(\n    e⁺::Function,\n    e⁻::Function,\n    f₊::Function,\n    f₋::Function,\n    g⁺::Function,\n    g⁻::Function,\n    p::Union{Nothing, Vector{<:Real}},\n    criteria_type::Symbol;\n    xlim,\n    initial_guess,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the Model type. \n\nArguments\n\ne₁ : the function e_1(x_1)\ne₂ : the function e_2(x_1)\nf₁ : the function f_1(x_1)\nf₂ : the function f_2(x_1)\ng₁ : the function g_1(x_1)\ng₂ : the function g_2(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\nxlim : limits for x axis, initialized to (0,10)\nnb_pts : number of points used for the plot, initialized to 100\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.check_root-Tuple{Function, Function, Function, Function, Vector{<:Real}, Symbol}","page":"API","title":"Filtration.check_root","text":"check_root(\n    e₁::Function,\n    e₂::Function,\n    f₁::Function,\n    f₂::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol;\n    xlim,\n    nb_pts,\n    initial_guess,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the Model type. \n\nnote: Note\nThis function is a wrapper of check_root function, where the functions g_1 and g_2 are set 1. This leads to dot x_2 = 1 with x_2(t_0) = 0, ie. x_2(t) = t.\n\nArguments\n\ne₁ : the function f_1(x_1)\ne₂ : the function f_2(x_1)\nf₁ : the function g_1(x_1)\nf₂ : the function g_2(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\nxlim : limits for x axis, initialized to (0,10)\nnb_pts: number of points used for the plot, initialized to 100\ninitial_guess : initial guess(es) for zero of the function. Initialized to nohting.\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.compute_phi-Tuple{Extremal, Model}","page":"API","title":"Filtration.compute_phi","text":"compute_phi(\n    extremal::Extremal,\n    model::Model;\n    p\n) -> Filtration.var\"#phi#106\"{Vector{var\"#s37\"}, Extremal, Model} where var\"#s37\"<:Real\n\n\nCompute the function  t mapsto phi(x(t) p(t)) of an Extremal computed on a Model. \n\nArguments\n\nextremal : the Extremal\nmodel : the Model\n\nKeyword arguments (optional)\n\np : a vector of parameter for the model (default is the parameters of the model).\n\nReturn\n\nphi : the function phi.\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.construct_extremal-Tuple{Model, Solution}","page":"API","title":"Filtration.construct_extremal","text":"construct_extremal(\n    model::Model,\n    solution::Solution;\n    p\n) -> Extremal\n\n\nConstruct an Extremal from a Solution from a Model.\n\nArguments\n\nmodel : a Model\nsolution: a Solution\n\nKeyword arguments (optional)\n\np : a vector of parameter for the model (default is the parametes of the model).\n\nReturn\n\nextremal : the Extremal\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.control-Tuple{Extremal}","page":"API","title":"Filtration.control","text":"control(extremal::Extremal) -> Control\n\n\nGetter for the Control of an Extremal.\n\nArguments\n\nextremal : an Extremal\n\nReturn\n\ncontrol : the Control of the Extremal\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.control-Tuple{Solution}","page":"API","title":"Filtration.control","text":"control(solution::Solution) -> Control\n\n\nGetter for the Control of a Solution.\n\nArguments\n\nsolution : a Solution\n\nReturn\n\nstate : the Control of the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.costate-Tuple{Extremal}","page":"API","title":"Filtration.costate","text":"costate(extremal::Extremal) -> Costate\n\n\nGetter for the Costate of an Extremal.\n\nArguments\n\nextremal : an Extremal\n\nReturn\n\ncostate : the Costate of the Extremal\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.cuts-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.cuts","text":"cuts(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> Tuple{SciMLBase.ODESolution, SciMLBase.ODESolution}\n\n\nCompute the cuts c_-(t) and c_+(t), which corresponds to the curves which leads to the singular state x_s at time T. The function c is the solution on t_0 T of\n\nleft beginarrayll\n    dot x_0 = e_-(x_1) - e_+(x_1)  quad x_0(T) = 0 dot x_1 = f_-(x_1) - f_+(x_1)  quad x_1(T) = x_s dot x_2 = g_-(x_1) - g_+(x_1)  quad x_2(T) = x_f- Delta_x\nendarray right\n\nand the function m is the solution on T t_f of \n\nleftbeginarrayll\n    dot x_0 = e_-(x_1) + e_+(x_1)  quad x_O(T) = 0 dot x_1 = f_-(x_1) + f_+(x_1)  quad x_1(T) = x_s dot x_2 = g_-(x_1) + g_+(x_1)  quad x_2(T) = x_f - Delta_x\nendarray right\n\nwarning: Warning\nThe cost x_0(T) at time T is initialized to 0. \n\nArguments\n\nmodel : a Model\nxlim : the limits of state x_2\nylim : the limits of state x_1 \n\nReturns\n\ncut₋ : the function c_-\ncut₊ : the function c_+\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.dispersal_locus-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}, SciMLBase.ODESolution, SciMLBase.ODESolution}","page":"API","title":"Filtration.dispersal_locus","text":"dispersal_locus(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real},\n    SL::SciMLBase.ODESolution,\n    cut₋::SciMLBase.ODESolution\n) -> SciMLBase.ODESolution\n\n\nFirst dispersal locus curve computed by continuation method. This curve is associated to the switching locus curve. \n\nA state x_1 x_2 belongs to the first dispersal curve if S(x_2 x_1) = 0, where S colon mathbb R^2 to mathbb R is defined by \n\nS(x_1 x_2) = varphi_0^+(x_1 x_2) - varphi_0^-+(x_1 x_2)\n\nwhere varphi_0^+ correponds to the final cost with the control u₊, and where varphi_0^-+ the final cost with the control u₋ ∘ u₊.  \n\nWe suppose that there exsits the switching locus DL(x_1) such that S(x_1 DL(x_1)) = 0. Since S is constant, we have \n\n    fracpartial Spartial x_1(x_1 DL(x_1)) + fracpartial Spartial x_2(x_1 DL(x_1)) DL(x_1) = 0\n\nBy the previous hypothesis, fracpartial Spartial x_2(x_1 DL(x_1)) is invertible. We have so \n\nDL(x_1) = -left( fracpartial Spartial x_2(x_1 DL(x_1)) right)^-1 fracpartial Spartial x_1(x_1 DL(x_1))\n\nThe continuation method consists to solve this ODE with the initial condition DL(x_s) = x_f - Delta x_2. Thanks to the combinaison of ForwardDiff and OrdinaryDiffEq package, the derivative of varphi_0^+ and varphi_0^-+ are computed by automatic differentiation methods by using the variational equations. \n\nThe end of the dispersal locus curve corresponds to the ylim[2] bouds or when the dispersal locus curve hit the cut₋ curve. \n\nwarning: Warning\nThis function must be used only when a dispersal locus happened, ie. when the end of the switching curve is below ylim[2]. \n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.real_solve-Tuple{Model, Real, Real, Real, Int64}","page":"API","title":"Filtration.real_solve","text":"real_solve(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real,\n    N::Int64;\n    method,\n    verbose\n) -> Solution\n\n\nProvide a real solution, where the control is only composed by -1 and 1 values, by the method. method can be :control, :state or :optimal. \n\nwarning: Warning\nIf method = :optimal, the computation must be long when N become large. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\nN : the number of subdivision of the singular arc\n\nKeyword arguments (optional)\n\nmethod : method used to get the real solution. Can be :control, :state or :optimal. Initialized to :state\nverbose : if true, print the optimization process (default is false)\n\nReturn\n\nreal_sol : the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.simulate-Tuple{Model, Control, Vector{<:Real}}","page":"API","title":"Filtration.simulate","text":"simulate(\n    model::Model,\n    control::Control,\n    x0::Vector{<:Real};\n    p\n) -> Solution\n\n\nSimulate a Control on a Model, starting from and initial state x(t_0) = x_0.\n\nArguments\n\nmodel : a Model\ncontrol : a Control\nx0: and intial state x(t_0) = x_0\n\nKeyword arguments (optional)\n\np : a vector of parameter for the model, (default is the parametes of the model).\n\nReturn\n\nsolution : the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solution-Tuple{Synthesis, Real, Real, Real}","page":"API","title":"Filtration.solution","text":"solution(\n    synthesis::Synthesis,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nWrapper to get solution from synthesis. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solve-Tuple{Model, Real, Real, Real}","page":"API","title":"Filtration.solve","text":"solve(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real;\n    cut₋,\n    cut₊,\n    SL,\n    DL,\n    DL2\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model by indirect shooting.\n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solve_MP-Tuple{Model, Real, Real, Real}","page":"API","title":"Filtration.solve_MP","text":"solve_MP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real;\n    SL\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model by indirect method, with the structure given by u_- circ u_+, and when the change is done by intersection with the switching curve\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solve_MSP-Tuple{Model, Real, Real, Real}","page":"API","title":"Filtration.solve_MSP","text":"solve_MSP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model, with the structure given by u_- circ u_s circ u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solve_P-Tuple{Model, Real, Real, Real}","page":"API","title":"Filtration.solve_P","text":"solve_P(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model, with the structure given by u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solve_PSP-Tuple{Model, Real, Real, Real}","page":"API","title":"Filtration.solve_PSP","text":"solve_PSP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting,  with the structure given by u_+ circ u_s circ u_+\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead.  \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0) \n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solve_SP-Tuple{Model, Real, Real, Real}","page":"API","title":"Filtration.solve_SP","text":"solve_SP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting,  with the structure given by u_+ circ u_s circ u_+\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead.  \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0) \n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.state-Tuple{Extremal}","page":"API","title":"Filtration.state","text":"state(extremal::Extremal) -> State\n\n\nGetter for the State of an Extremal.\n\nArguments\n\nextremal : an Extremal\n\nReturn\n\nstate : the State of the Extremal\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.state-Tuple{Solution}","page":"API","title":"Filtration.state","text":"state(solution::Solution) -> State\n\n\nGetter for the State of a Solution.\n\nArguments\n\nsolution : a Solution\n\nReturn\n\nstate : the State of the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.switching_locus-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.switching_locus","text":"switching_locus(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> SciMLBase.ODESolution\n\n\nSwitching locus function computed by continuation method.\n\nA state x_1 x_2 belongs to the switching curve if S(x_2 x_1) = 0, where S colon mathbb R^2 to mathbb R is defined by \n\nS(x_2 x_1) = H(x_1 varphi_1(x_1 x_2))\n\nThe function varphi_1 coresponds to the solution at the final time of the state x_1 by applying the control u_+, and the function H is defined by \n\n    H(x_1 x_1f) = lambda_1(x_1 x_1f) (f_+(x_1) + f_-(x_1)) + lambda_2(x_1f)(g_+(x_1) + g_-(x_1)) - (e_+(x_1) + e_-(x_1))\n\nwhere \n\n    lambda_1(x_1 x_1f) = frace_+(x_1) - lambda_2(x_1f) g_+(x_1)f_+(x_1)\n\nand \n\n    lambda_2(x_1f) =  frace_+(x_1) + e_-(x_1)g_+(x_1) + g_-(x_1) \n\nWe suppose that there exsits the switching locus SL(x_1) such that S(x_1 SL(x_1)) = 0. Since S is constant, we have \n\n    fracpartial Spartial x_1(x_1 SL(x_1)) + fracpartial Spartial x_2(x_1 SL(x_1)) SL(x_1) = 0\n\nBy the previous hypothesis, fracpartial Spartial x_2(x_1 SL(x_1)) is invertible. We have so \n\nSL(x_1) = -left( fracpartial Spartial x_2(x_1 SL(x_1)) right)^-1 fracpartial Spartial x_1(x_1 SL(x_1))\n\nThe continuation method consists to solve this ODE with the initial condition SL(x_s) = x_f - Delta x_2. Thanks to the combinaison of ForwardDiff and OrdinaryDiffEq package, the derivative of varphi_1 is computed by automatic differentiation methods by using the variatomal equations. \n\nArguments\n\nmodel: a Model\nxlim : the limits of the state x_2\nylim : the limits of the state x_1\n\nReturn\n\nSL : the switching locus function, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot!-Tuple{Plots.Plot, Control}","page":"API","title":"RecipesBase.plot!","text":"plot!(\n    plt::Plots.Plot,\n    control::Control;\n    color,\n    label,\n    kwargs...\n)\n\n\nAdd a Control to a plot \n\nArguments\n\nplt : a Plot\ncontrol : a Control\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the classical theme palette)\nlabel : the label of the plot (default is an empy string)\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot!-Tuple{Plots.Plot, Costate}","page":"API","title":"RecipesBase.plot!","text":"plot!(\n    plt::Plots.Plot,\n    costate::Costate;\n    color,\n    label,\n    subplot,\n    kwargs...\n)\n\n\nPlot a costate\n\nArguments\n\ncostate : a Costate\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the classical theme palette)\nlabel : the label of the plot (default is an empy string)\nsubplot : the initial subplot number (default is 1)\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot!-Tuple{Plots.Plot, Extremal}","page":"API","title":"RecipesBase.plot!","text":"plot!(\n    plt::Plots.Plot,\n    extremal::Extremal;\n    color,\n    label,\n    kwargs...\n)\n\n\nAdd an Extremal on a Plot\n\nArguments\n\nplt : a Plots.Plot\nextremal : an Extremal\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the theme palette)\nlabel : the label of the plot (default is \"\")\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot!-Tuple{Plots.Plot, Solution}","page":"API","title":"RecipesBase.plot!","text":"plot!(\n    plt::Plots.Plot,\n    solution::Solution;\n    color,\n    kwargs...\n) -> Plots.Plot\n\n\nAdd a Solution on a plot \n\nArguments\n\nplt : a Plots.Plot\nsolution : a Solution\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the theme palette)\nlabel : the label of the plot (default is \"\")\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot!-Tuple{Plots.Plot, State}","page":"API","title":"RecipesBase.plot!","text":"plot!(\n    plt::Plots.Plot,\n    state::State;\n    color,\n    subplot,\n    label,\n    kwargs...\n)\n\n\nAdd a State to a plot\n\nArguments\n\nstate : a State\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the classical theme palette)\nlabel : the label of the plot (default is an empy string)\nsubplot : the initial subplot number (default is 1)\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Control}","page":"API","title":"RecipesBase.plot","text":"plot(\n    control::Control;\n    color,\n    ylim,\n    label,\n    titlefontsize,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Control \n\nArguments\n\ncontrol : a Control\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the classical theme palette)\nylim : the y limits of the plot (default is (-1.1, 1.1))\nlabel : the label of the plot (default is an empy string)\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Costate}","page":"API","title":"RecipesBase.plot","text":"plot(\n    costate::Costate;\n    color,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Costate \n\nArguments\n\ncostate : a Costate\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the classical theme palette)\nlabel : the label of the plot (default is an empy string)\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Extremal}","page":"API","title":"RecipesBase.plot","text":"plot(\n    extremal::Extremal;\n    size,\n    color,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot an Extremal\n\nArguments\n\nextremal : an Extremal\n\nKeyword arguments (optional)\n\nsize : the size of the plot (default is (600, 350))\ncolor : the color of the plot (default is the first color of the classical theme palette)\nlabel : the label of the plot (default is empty string)\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{MultiSynthesis}","page":"API","title":"RecipesBase.plot","text":"plot(\n    s::MultiSynthesis;\n    feedback_form,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a MultiSynthesis, in a classification of optimal control form or in a feedback form.\n\nArguments\n\nmultisynthesis : a MultiSynthesis\n\nKeyword arguments (optional)\n\nfeedback_form : if true, plot in a feedback form. If false, in a classification of optimal control form. Initialized to true\nkwargs... : keyword arguments for plot \n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Solution}","page":"API","title":"RecipesBase.plot","text":"plot(\n    solution::Solution;\n    state_ylabels,\n    size,\n    color,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Solution \n\nArguments\n\nsolution : a Solution\n\nKeyword arguments (optional)\n\nsize : the size of the plot (default is (600, 350))\ncolor : the color of the plot (default is the first color of the theme palette)\nlabel : the label of the plot (default is \"\")\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{State}","page":"API","title":"RecipesBase.plot","text":"plot(\n    state::State;\n    ylabels,\n    color,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a State \n\nArguments\n\nstate : a State\n\nKeyword arguments (optional)\n\ncolor : the color of the plot (default is the first color of the classical theme palette)\nlabel : the label of the plot (default is an empy string)\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Synthesis}","page":"API","title":"RecipesBase.plot","text":"plot(\n    s::Synthesis;\n    feedback_form,\n    SL_nb_points,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Synthesis, in a classification of optimal control form or in a feedback form.\n\nArguments\n\ns : a Synthesis\n\nKeyword arguments (optional)\n\nfeedback_form : if true, plot in a feedback form. If false, in a classification of optimal control form. Initialized to false\nSLnbpoints : Number of points for the switching locus curve. Initialized to nothing (points of the ODESolution`)\nkwargs... : keyword arguments for plot \n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"2Res_CT.html#Studied-problem","page":"Control-Toolbox","title":"Studied problem","text":"","category":"section"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"We are looking now to a more complex problem where there are two kinds of masses attached to the membrane, described by two resistances r_1 and r_2.","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"Since the code provide in the Filtration.jl package only look for the case of one resistance/mass, this page proposes to show how one can use the control-toolbox ecosystem throught the OptimalControl.jl package to get the optimal solution of the following problem.","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"using Plots\nusing OptimalControl\n\nt0 = 0.\nvf = 10.\nx0 = [0., 0., 0.1, 0.1]\np = [1., 1., 1., 1., 2., 1.5]\n\ne(x) = p[1] + x[3] + x[4]\ng(x) = p[2]\nf₁₁(x) = p[3]\nf₁₂(x) = - p[4]*x[3]\nf₂₁(x) = p[5]\nf₂₂(x) = - p[6]*x[4]\n\n# Vector fields\nFf(x) = [e(x);  g(x); f₁₁(x); f₂₁(x)]\nFb(x) = [e(x); -g(x); f₁₂(x); f₂₂(x)]\nF0(x) = Ff(x) + Fb(x)\nF1(x) = Ff(x) - Fb(x)\n\nocp = @def begin\n    tf ∈ R, variable \n    t ∈ [t0, tf], time\n    x = (e, v, r1, r2) ∈ R⁴, state\n    u ∈ R, control\n    -1 ≤ u(t) ≤ 1\n    x(t0) == x0\n    v(tf) == vf\n    ẋ(t) == F0(x(t)) + u(t)*F1(x(t))\n    e(tf) → min\nend","category":"page"},{"location":"2Res_CT.html#Direct-method","page":"Control-Toolbox","title":"Direct method","text":"","category":"section"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"One classical optimal control method used to get a solution of the problem is the direct one. The main idea is to discretize in time the studied optimal control problem, to formulate the associated large optimization problem and to solve it. Thanks to the OptimalControl.jl package, one can easily have and plot the solution of the direct method by using the solve function. Here we use the interior point Ipopt solver to get a solution of the discretized problem. ","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"using NLPModelsIpopt\n\ndirect_sol = solve(ocp; display = true)\nplt_sol = plot(direct_sol, label = \"direct\")","category":"page"},{"location":"2Res_CT.html#Structure-of-the-solution","page":"Control-Toolbox","title":"Structure of the solution","text":"","category":"section"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"As we can see, the structure of the optimal solution is composed by a bang arc u = 1, followed by a singular arc u = u_s(xlambda) and finished by a bang arc u = +1. To verify this, we vaan verify that the switching function t mspato H_1(x(t) lambda(t)) vanished along the singular arc. The expression of the singular control is simply computed thanks to the OptimalControl.jl package, see this tutorial for more information about how it is done. ","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"note: Note\nFor the computation of the singular control, one suppose that there exists I subset t_0 t_f such that H_1(x(t) lambda(t)) = 0 for almost all t in I.  Denoting H G the Poisson bracket of two Hamiltonians H and G defined by    H G = (nabla p H -nabla x H) cdot Gthe minimal order singular control is given by     u_s(xlambda) = -fracH_001H_101 = -fracH_0H_0 H_1H_1 H_0 H_1","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"using OrdinaryDiffEq\n\n# Lift into (x,λ) space\nH0 = Lift(F0)\nH1 = Lift(F1)\n\n# Lie bracket\nH01  = @Lie {H0, H1}\nH001 = @Lie {H0, H01}\nH101 = @Lie {H1, H01}\n\n# Singular control\nus(x, λ) = -H001(x, λ) / H101(x, λ)\n\n# Pseudo-Hamiltonian\nH(x,λ,u) = H0(x,λ) + u*H1(x,λ)\n\n# Flows (Change for plot the control)\nϕ0 = Flow(ocp, (x,λ,tf) -> -1)\nϕ1 = Flow(ocp, (x,λ,tf) -> +1)\nϕs = Flow(ocp, (x,λ,tf) -> us(x,λ))\n\n# Get direct trajectory\ntime = time_grid(direct_sol)\nx = state(direct_sol)\nu = control(direct_sol)\nλ = costate(direct_sol)\ntf = time[end]\n\n# Structure of the solution \nplot( t -> H0(x(t), λ(t)), t0, tf, label = \"H₀(x(t), λ(t))\")\nplot!(t -> H1(x(t), λ(t)), t0, tf, label = \"H₁(x(t), λ(t))\")\nplot!(t -> H01(x(t), λ(t)), t0, tf, label = \"H₀₁(x(t), λ(t))\")","category":"page"},{"location":"2Res_CT.html#Indierct-shooting","page":"Control-Toolbox","title":"Indierct shooting","text":"","category":"section"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"We are now able to solve the studied optimal control problem by indirect shooting method. The goal is to find a zero of the function S defined below. Thanks to the direct solution, we can have a good initial guess of the zero of S. ","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"using LinearAlgebra: norm\n\n# Shooting function\nfunction shoot!(s, ξ)\n    λv0, λr10, λr20, t1, t2, tf = ξ\n    x1, λ1 = ϕ1(t0, x0, [-1, λv0, λr10, λr20], t1)\n    x2, λ2 = ϕs(t1, x1, λ1, t2)\n    xf, λf = ϕ1(t2, x2, λ2, tf)\n\n    s[1] = xf[2] - vf\n    s[2:3] = λf[3:4]\n    s[4] = H0(x1, λ1)\n    s[5] = H1(x1, λ1)\n    s[6] = H01(x1, λ1)\nend\n\n# Jacobian of the shooting function\njshoot! = (js, ξ) -> jacobian!(shoot!, similar(ξ), js, AutoForwardDiff(), ξ)\n\n# Initial guess\nλ0 = λ(t0)\nη = 1e-3\ntime_ = time[ u.(time) .≤ 1-η ]\nt1 = time_[1]; t2 = time_[end]\nξ = [λ0[2:4]..., t1, t2, tf]\n\ns = similar(ξ)\nshoot!(s, ξ)\nprintln(\"\\nNorm of the initial guess of the shooting function: ‖s‖ = \", norm(s), \"\\n\")","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"We propose to use hybrd1 method which is a modified version of Powell's algorithm to find a zero of S, given by the MINPACK.jl package. ","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"using MINPACK\nusing DifferentiationInterface\nimport ForwardDiff\n\n# Resolution of S(ξ) = 0\nindirect_sol = fsolve(shoot!, jshoot!, ξ, show_trace=true)\nshoot!(s, indirect_sol.x)\nprintln(\"\\nNorm of the solution of the shooting function: ‖s‖ = \", norm(s), \"\\n\")\n\n# Plot\nλv0, λr10, λr20, t1, t2, tf = indirect_sol.x\nϕ = ϕ1 * (t1, ϕs) * (t2, ϕ1)\nflow_sol = ϕ((t0, tf), x0, λ0; saveat=range(t0, tf, 1000))\nplot!(plt_sol, flow_sol, label=\"indirect\")","category":"page"},{"location":"2Res_CT.html#Turnpike-property","page":"Control-Toolbox","title":"Turnpike property","text":"","category":"section"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"Our goal now is simply to numerically highlight the turnpike property of our ploblem. To do this, we found steady state on r_1 and r_2 which minimize  dot e - lambda_v dot v where lambda_v coresponds to the optimal constant costate associated to v. To do this, we use the Ipopt solver throught the Optimization.jl package. ","category":"page"},{"location":"2Res_CT.html","page":"Control-Toolbox","title":"Control-Toolbox","text":"using Ipopt, Optimization, OptimizationMOI\n# Constraints\nfunction cons!(dξ, ξ,_)\n    r1, r2, u = ξ\n    x = [0., 0., r1, r2]\n    dx = F0(x) + u*F1(x)\n    dξ .= dx[3:4]\nend\n\n# Objective \nfunction obj(ξ,_)\n    r1, r2, u = ξ\n    x = [0., 0., r1, r2]\n    dx = F0(x) + u*F1(x)\n    return dx[1] - λv0*dx[2]\nend\n\n# Initial guess\nx, λ = ϕ(t0, x0, λ0, (t1 + t2)/2)\nu = us(x, λ)\nξ = [x[3:4]; u]\n\n# Definition of the optimization problem\noptprob = OptimizationFunction(obj, AutoForwardDiff(), cons = cons!)\nprob = OptimizationProblem(optprob, ξ, nothing, lcons = [0., 0.], ucons = [0., 0.])\nopt_sol = Optimization.solve(prob, Ipopt.Optimizer(), print_level = 5)\n\n# Plot\nst = opt_sol.u\nplt_sol = plot(flow_sol, label = \"\")\nplot!(plt_sol, [t0, tf], [st[1], st[1]], subplot = 3, label = \"\")\nplot!(plt_sol, [t0, tf], [st[2], st[2]], subplot = 4, label = \"\")\nplot!(plt_sol, [t0, tf], [st[3], st[3]], subplot = 9, label = \"\")","category":"page"},{"location":"fit.html#Fit-model-to-data","page":"Fit data","title":"Fit model to data","text":"","category":"section"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"Data from real membrane filtration systems could be obtained, and the goal now is to fit these kind of data to a simulation model. Such data corresponds to the volume v and/or energy e during time, but the mass m attached to it could not be observed.  ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"using Filtration\nusing Plots\nusing LinearAlgebra:norm","category":"page"},{"location":"fit.html#Synthetic-data","page":"Fit data","title":"Synthetic data","text":"","category":"section"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"On this tutorial, data are generated from the following model with the following parameters p. ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"a = 1; b = 1; e = 1;\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -p[1] * m\ng(m,p)  = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nmodel = Model(g₁, g₂, f₁, f₂, p, :max, initial_guess = 2.)","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"n data are generated with a normal noise varepsilon with a choosen control.","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"n = 100\nε = 0\nu₁ = 0.6; u₂ = 0.8\nt0 = 0.; t1 = 25.; tf = 50. \nu = Control([t -> u₁ , t -> u₂], [t0, t1, tf], 2, 1)\nx0 = [0., 4., 0.]\nsol = simulate(model, u, x0)\nt = collect(range(u.time[1], u.time[end], n))\ndata = [x[1] for x ∈ sol.state.(t)] + ε*(randn(n) .- 0.5)\nplt = plot(sol, state_ylabels = [\"v\", \"m\", \"t\"])\nscatter!(plt, t, data, subplot = 1, label = \"data\", mc = :red, ma = 0.5, ms = 2)","category":"page"},{"location":"fit.html#Known-initial-guess","page":"Fit data","title":"Known initial guess","text":"","category":"section"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"Let assume that the initial mass m(t_0) = m_0 is known. The parameters can be easily fitted to the data","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"initial_p = [0.5, 0.5, 0.5]\nfitted_p = fit(model, u, t, data, initial_p, x0, method = :known)\nprintln(\"Error norm : \", norm(fitted_p - p))\nsol_init = simulate(model, u, x0; p = initial_p)\nsol_sim = simulate(model, u, x0; p = fitted_p)\nplt = plot(sol, state_ylabels = [\"v\", \"m\", \"t\"], label = \"Real\")\nplot!(plt, sol_init, c = :red, label = \"Initial\", ls = :dash)\nscatter!(plt, t, data, subplot = 1, label = \"data\", mc = :red, ma = 0.5, ms = 2)\nplot!(sol_sim, label = \"Fitted\", c = :green, ls = :dash)","category":"page"},{"location":"fit.html#Unknown-initial-guess","page":"Fit data","title":"Unknown initial guess","text":"","category":"section"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"Let assume now that the initial mass m(t_0) is not known. One proposes to apply a constant control u = u_1 during a time interval t_0 t_1 until the steady state m_1 is reach, and to change the control after to u = u_2 during t_1 t_f. Thanks to the first arc, some informations could be obtained. ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"First, at steady state, we have ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"    dot m(t) = 0 quad Longrightarrow quad f_0(m_1p) + u_1 f_1(m_1p) = 0","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"where f_0 and f_1 corresponds to the functions of the m dynamic. Such equation leads to ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"    m(t_1) approx m_1 = psi(u_1 p)","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"where psi is the inverse of m \\mapsto \\frac{-f_0(m,p)}{f_1(m,p)}. ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"Second, at steady state, we have ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"    dot v(t) = g_0(m_1p) + u_1 g_1(m_1p) = c","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"where c is constant. ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"Both constraints on mass m(t_1) and dot v are used to fit parameters with unknown initial guess on the second singular arc. ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"To do this, one first need to compute c on the first arc as the slope of v at steady state. ","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"# Affine fit function\nfunction affine_fit(x, y)\n    x = [x ones(length(x))]\n    y = [y ones(length(y))]\n    coeffs = x \\ y\n    return coeffs[1], coeffs[2]\nend\n\n# R2 test\nfunction R2(x, y, a, b)\n    y_hat = a*x .+ b\n    mean_y = sum(y) / length(y)\n    ss_res = sum((y .- y_hat).^2)\n    ss_tot = sum((y .- mean_y).^2)\n    return 1 - (ss_res / ss_tot)\nend\n\n# First arc data\nt_ = t[t.<t1]\ndata_ = data[t.<t1]\n\n# Compute R2 for n removed points\nall_n = collect(1:length(t_)-5)\nall_t = []\nall_r2 = []\nfor n ∈ all_n\n    a, b = affine_fit(t_[n:end], data_[n:end])\n    push!(all_r2, R2(t_[n:end], data_[n:end], a, b))\n    push!(all_t, t_[n])\nend\n\n# Get n wrt R2\nε = 1e-5\nind = findfirst(1 .- all_r2 .< ε )\n\n# Print & Plot\nslope, intercept = affine_fit(t_[all_n[ind]:end], data_[all_n[ind]:end])\nprintln(\"Slope of v̇ at steady state : \", slope)\nplt = plot(all_t, all_r2, xlabel = \"Number of unused points\", ylabel = \"R²\", label = \"\")\nscatter!(plt, [all_t[ind]], [all_r2[ind]], color = :black, label = \"Selected number\")","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"By providing this slope c and the function phi (as the get_m function), we can esily fit parameters p of the model on the data of the second arc","category":"page"},{"location":"fit.html","page":"Fit data","title":"Fit data","text":"# Inverse of -f₋/f₊\nfunction get_m(u, p)\n    Δ = p[3]^2 - 4*(p[2]* (u+1))/(p[1]* (u-1))\n    m = (-p[3] + sqrt(Δ))/2\n    return m\nend \n\nt_ = t[t.>t1]\nt_ = t_ .- t_[1]\ndata_ = data[t.>t1]\ndata_ = data_ .- data_[1]\nu_ = Control([t -> u₂], [0, tf - t1], 1, 1)\nx0_ = [0., 3., 0.]\n\nfitted_p = fit(model, u_, t_, data_, initial_p, x0_; method = :unknown, get_m = get_m, u = u₁, slope = slope)\nprintln(\"Error norm : \", norm(fitted_p - p))\nsol_sim = simulate(model, u, x0; p = fitted_p)\nplt = plot(sol, state_ylabels = [\"v\", \"m\", \"t\"], label = \"Real\")\nscatter!(plt, t, data, subplot = 1, label = \"data\", mc = :red, ma = 0.5, ms = 2)\nplot!(sol_sim, label = \"Fitted\", c = :green, ls = :dash)","category":"page"},{"location":"model.html#Model-creation","page":"Model","title":"Model creation","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"In this tutorial, we explain how to create a Model from Filtration.jl package. ","category":"page"},{"location":"model.html#Basic-usage","page":"Model","title":"Basic usage","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Let us start by defining the input functions of the problem ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"using Filtration\n\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) =  p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\nnothing; # hide","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"Before creating a model, it is recommended to use the check_root function to ensure that the plotted function have only one root. ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"note: Note\nThe symbol :min correspond to the objective. It can be also :min or :max. This symbol is also used for the creation of the model. ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"check_root(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; xlim = (0, 30))","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"A model of can be created with the following code ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"model = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min)\nnothing; #hide","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"If needed, an initial guess of the zero of the function plot by the check_root function can be provided to the Model","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"model = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min, initial_guess = 20.)\nnothing; #hide","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"If only 4 functions are provided, the functions are set to g_1(\\cdot) = g_2(\\cdot) = 1 to ensure that x_2(t) = t. The following code highlight this case","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"a = 1; b = 1; e = 1;\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -p[1] * m\ng(m,p)  = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nplt = check_root(g₁, g₂, f₁, f₂, p, :max)\nmodel = Model(g₁, g₂, f₁, f₂, p, :max, initial_guess = 2.)\nplt","category":"page"},{"location":"model.html#Optimal-strategies-and-optimal-synthesis-maps","page":"Model","title":"Optimal strategies and optimal synthesis maps","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Defining the limits xlim and ylim of the plot, the optimal control stategies plot can be shown from a model by the following code. ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"warning: Warning\nThe maximum limit of the x-axis, i.e. xlim[2] corresponds to the terminal condition of the second state.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"xlim = (0,10); ylim = (0,10)\nsynthesis = Synthesis(model, xlim, ylim)\nplt = plot(synthesis)","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"However, the classical optimal synthesis can be plotted by setting feedback_form = true.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"plt = plot(synthesis, feedback_form = true)","category":"page"},{"location":"real_solve.html#From-optimal-solution-to-real-solution","page":"Real solution","title":"From optimal solution to real solution","text":"","category":"section"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"The goal is now to present how we can approximate an optimal solution to a real control, in which the control can only take the values -1 or 1. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"To do this, let first define a model ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"using Filtration\nusing Plots\n\nvlim = (0,200); mlim = (0,100)\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) = -p[1]*m + p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\n\nmodel = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 15.)\n\nsynthesis = Synthesis(model, vlim, mlim)\nplt_synthesis = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\", legend = :topleft)","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"Let fix for instance x_1(t_0) = m_0 = 40 and x_2(t_0) = v_0 = 5, and compute the solution of the problem. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"v0 = 5; m0 = 40.\nsol = solution(synthesis, v0, vlim[2], m0)\nplot(sol, label = \"optimal \")","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"add_solution_to_synthesis!(plt_synthesis, sol, axis_arrow = :x, label = \"optimal \")","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"As we can see, the control u(cdot) on the singular arc take a value between -1 and 1, which is not really applicable on a real membrane. We propose three method to provide a real control solution. For all these method, we need to fix a number N of swiching, which will be in this example fixed to N = 5","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"N = 5;\nnothing; #hide ","category":"page"},{"location":"real_solve.html#Method-1-:-Control-approximation","page":"Real solution","title":"Method 1 : Control approximation","text":"","category":"section"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"The first method, named :control, approximate the singular control u(cdot) = u_s by -1 and 1 value on each subsegments. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"Let assume that the optimal solution have a singular arc on T_1 T_2. This interval of time is divised by N subintervals of time Delta_i = t_i t_i+1 where i in  1   N  and where  ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"t_i = T_1 + (i-1) * Delta t quad Delta t = fracT_2 - T_1N","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"On each subintervals of time Delta_i, the time spend with u = +1 with respect to the time spend with u = -1 is proportional to the value of the singular control u_s in -1 1. In other words, the (real) control u(cdot) is defined for all i in  1   N  on the singular arc by ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"u(t) = left  beginarrayll \n    +1  quad forall t in t_i t_i + delta t \n    -1  quad forall t in t_i + delta t t_i+1\nendarray right\nquad text where  quad delta t = Delta t  fracu_s + 12  ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"This following code shows the results of this method. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"real_sol₁ = real_solve(model, v0, vlim[2], m0, N, method = :control)\nplt_solution = plot(sol, label = \"optimal \")\nplot!(plt_solution, real_sol₁, label = \":control \", color = :blue)","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"plt_synthesis = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\", legend = :topleft)\nadd_solution_to_synthesis!(plt_synthesis, sol, axis_arrow = :x, label = \"optimal \", linewidth = 2)\nadd_solution_to_synthesis!(plt_synthesis, real_sol₁, axis_arrow = :x, color = :blue, label = \":control \")","category":"page"},{"location":"real_solve.html#Method-2-:-Singular-state-approximation","page":"Real solution","title":"Method 2 : Singular state approximation","text":"","category":"section"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"The second method, named :singular, is based on the singular arc approximation. The main idea is to subdivise the singular arc intro N subsegments and to find the optimal control of structure u_+ circ u_- circ u_+ that minimise the energy and that satisfy that the final state (on x_1 and x_2) corresponds to the one of the end of the subsegments of the singular arc defined above. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"note: Note\nHere we use the fact that the problem is autonomous, and therefore we just have to solve a small optimization problem to define the whole trajecotry of state. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"Denoting T_1 the begining time of the singular arc, the singular control is defined for all i in  1  N  by ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"u(t) = left  beginarrayll \n    +1  quad forall t in T_1 + (i-1) delta t_3 T_1 + (i-1) delta t_3 + delta t_1 \n    -1  quad forall t in T_1 + (i-1) delta t_3 + delta t_1 T_1 + (i-1) delta t_3 + delta t_2 \n    +1  quad forall t in T_1 + (i-1) delta t_3 + delta t_2 T_1 + i delta t_3\nendarray right","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"where delta t_1, delta t_2 and delta t_3 are solution of the following optimization problem ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"left  beginarrayl\n    min_delta t_1 delta t_2 delta t_3 phi_0^+-+(delta t_1 delta t_2 delta t_3) \n    textrmst  phi_1^+-+(delta t_1 delta t_2 delta t_3) = x_s \n    phantomtextrmst  phi_2^+-+(delta t_1 delta t_2 delta t_3) = delta x_2\nendarrayright","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"where phi_k^+-+ corresponds to the value of the final state k (0 for the cost) by applying the control +1 on 0 delta t_1, the control -1 on delta t_1 delta t_2 and the control +1 on delta t_2 delta t_3. The value delta x_2 is computed by the subdivision of the singular arc and x_s corresponds to the value of the singular state. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"Here is the result for this method ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"real_sol₂ = real_solve(model, v0, vlim[2], m0, N, method = :singular)\n\nplt_solution = plot(sol, label = \"optimal \")\nplot!(plt_solution, real_sol₂, label = \":singular \", color = :red)","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"plt_synthesis = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\", legend = :topleft)\nadd_solution_to_synthesis!(plt_synthesis, sol, axis_arrow = :x, label = \"optimal \", linewidth = 2)\nadd_solution_to_synthesis!(plt_synthesis, real_sol₂, axis_arrow = :x, color = :red, label = \":singular \")","category":"page"},{"location":"real_solve.html#Method-3-:-Optimal-real-solution","page":"Real solution","title":"Method 3 : Optimal real solution","text":"","category":"section"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"The third method computes the real optimal real solution of the problem. Here we define the large optimization problem which consists to find the values of the switching time which minimize the cost and satisfy the boundary conditions. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"warning: Warning\nThis method could not be used if N is large, due to the computation time. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"Here the code to obtain the optimal real solution ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"real_sol₃ = real_solve(model, v0, vlim[2], m0, N, method = :optimal)\n\nplt_solution = plot(sol, label = \"optimal \")\nplot!(plt_solution, real_sol₃, label = \":optimal \", color = :green)","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"plt_synthesis = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\", legend = :topleft)\nadd_solution_to_synthesis!(plt_synthesis, sol, axis_arrow = :x, label = \"optimal \", linewidth = 2)\nadd_solution_to_synthesis!(plt_synthesis, real_sol₃, axis_arrow = :x, color = :green, label = \":optimal \")","category":"page"},{"location":"real_solve.html#Comparison","page":"Real solution","title":"Comparison","text":"","category":"section"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"We compare these three methods in terms of optimality and computation time. ","category":"page"},{"location":"real_solve.html","page":"Real solution","title":"Real solution","text":"<img src=\"https://github.com/remydutto/doc-Filtration.jl/blob/main/ressources/plots/computation_real_control.png?raw=true\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"600px\">\n<br>","category":"page"},{"location":"dev-filtration.html#dev-filtration","page":"Developpers","title":"Filtration.jl private functions","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-filtration.html#Index","page":"Developpers","title":"Index","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Pages   = [\"dev-filtration.md\"]\nModules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-filtration.html#Documentation","page":"Developpers","title":"Documentation","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Modules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-filtration.html#Filtration.__compute_phi-Tuple{Real, Extremal, Model}","page":"Developpers","title":"Filtration.__compute_phi","text":"__compute_phi(t::Real, extremal::Extremal, model::Model; p)\n\n\nCompute the value of the function  t mapsto phi(x(t) p(t)) on a given time t of an Extremal computed on a Model. \n\nArguments\n\nt : a real time t\nextremal : the Extremal\nmodel : the Model\n\nKeyword arguments (optional)\n\np : a vector of parameter for the model (default is the parametes of the model).\n\nReturn\n\nphi : the value of phi(t). \n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.__get_time-Tuple{Synthesis, Synthesis, Real}","page":"Developpers","title":"Filtration.__get_time","text":"__get_time(\n    synthesis1::Synthesis,\n    synthesis2::Synthesis,\n    xmax::Real\n) -> Real\n\n\nProvide the time t_2 on the singuar arc associated to synthesis2 where the cost of the optimal solution of staying on this singular arc is equal to leave it for hitting the singular arc associated to synthesis1. \n\nArguments\n\nsynthesis1 : the below Synthesis\nsynthesis2 : the above Synthesis\nxmax : the max of the x-axis\n\nReturn\n\nt2 : the time \n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.__sep-Tuple{Synthesis, Synthesis, Real}","page":"Developpers","title":"Filtration.__sep","text":"__sep(\n    synthesis1::Synthesis,\n    synthesis2::Synthesis,\n    xmax::Real\n) -> SciMLBase.ODESolution\n\n\nProvide the separation curve of two synthesis by diffetial continuation method. \n\nArguments\n\nsynthesis1 : the below Synthesis\nsynthesis2 : the above Synthesis\nxmax : the max of the x-axis\n\nReturn\n\nsol : the separation curve, as an ODESolution \n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.classification_plot-Tuple{Synthesis}","page":"Developpers","title":"Filtration.classification_plot","text":"classification_plot(\n    s::Synthesis;\n    SL_nb_points,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Synthesis, in a classification of optimal control form\n\nArguments\n\nsynthesis : a Synthesis\n\nKeyword arguments (optional)\n\nSLnbpoints : Number of points for the switching locus curve. Initialized to nothing (points of the ODESolution`)\nkwargs... : keyword arguments for plot \n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.dispersal_locus_2-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}, SciMLBase.ODESolution}","page":"Developpers","title":"Filtration.dispersal_locus_2","text":"dispersal_locus_2(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real},\n    DL::SciMLBase.ODESolution\n) -> SciMLBase.ODESolution\n\n\nSecond dispersal locus curve computed by continuation method. This curve is associated to the singular curve. \n\nA state x_1 x_2 belongs to the second dispersal curve if S(x_2 x_1) = 0, where S colon mathbb R^2 to mathbb R is defined by \n\nS(x_1 x_2) = varphi_0^+(x_1 x_2) - varphi_0^-s+(x_1 x_2)\n\nwhere varphi_0^+ correponds to the final cost with the control u₊, and where varphi_0^-s+ the final cost with the control u₋ ∘ uₛ ∘ u₊.  \n\nWe suppose that there exsits the switching locus DL2(x_1) such that S(x_1 DL2(x_1)) = 0. Since S is constant, we have \n\n    fracpartial Spartial x_1(x_1 DL2(x_1)) + fracpartial Spartial x_2(x_1 DL2(x_1)) DL2(x_1) = 0\n\nBy the previous hypothesis, fracpartial Spartial x_2(x_1 DL2(x_1)) is invertible. We have so \n\nDL2(x_1) = -left( fracpartial Spartial x_2(x_1 DL2(x_1)) right)^-1 fracpartial Spartial x_1(x_1 DL2(x_1))\n\nThe continuation method consists to solve this ODE with the initial condition DL2(x_s) = x_f - Delta x_2. Thanks to the combinaison of ForwardDiff and OrdinaryDiffEq package, the derivative of varphi_0^+ and varphi_0^-s+ are computed by automatic differentiation methods by using the variational equations. \n\nThe end of the dispersal locus curve corresponds to the ylim[2] \n\nwarning: Warning\nThis function must be used only when a second dispersal locus happened, ie. when the end of the first dispersal locus is below ylim[2]. \n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.get_arrow_time-Tuple{Vector{<:Real}, SciMLBase.ODESolution, Symbol}","page":"Developpers","title":"Filtration.get_arrow_time","text":"get_arrow_time(\n    value::Vector{<:Real},\n    sol::SciMLBase.ODESolution,\n    axis::Symbol\n) -> Vector{<:Real}\n\n\nCompute the time t for which sol(t) ∈ y_value\n\nArguments\n\ny_value : vector of y-axis value\nsol : state trajectory as an ODESolution\n\nReturn\n\ntimes : Vector of times\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.real_solve_control-Tuple{Model, Real, Real, Real, Int64}","page":"Developpers","title":"Filtration.real_solve_control","text":"real_solve_control(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real,\n    N::Int64\n) -> Solution\n\n\nProvide the real solution, where the control is only composed by -1 and 1 values. In this method, the control is approximated by -1 and 1 with respect to the value of uₛ. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\nN : the number of subdivision of the singular arc\n\nReturn\n\nreal_sol : the Solution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.real_solve_optimal-Tuple{Model, Real, Real, Real, Int64}","page":"Developpers","title":"Filtration.real_solve_optimal","text":"real_solve_optimal(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real,\n    N::Int64;\n    verbose\n) -> Solution\n\n\nProvide the optimal real solution, where the control is only composed by -1 and 1 values. In this method, the global constraints non linear optimization problem is constructed and solved.\n\nwarning: Warning\nThis method must be long when N become large. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\nN : the number of subdivision of the singular arc\n\nKeyword arguments (optional)\n\nverbose : if true, print the optimization process (default is false)\n\nReturn\n\nreal_sol : the Solution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.real_solve_singular-Tuple{Model, Real, Real, Real, Int64}","page":"Developpers","title":"Filtration.real_solve_singular","text":"real_solve_singular(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real,\n    N::Int64;\n    verbose\n) -> Solution\n\n\nProvide a real solution, where the control is only composed by -1 and 1 values. In this method, the singular arc is subdivided into N intervals. On each subintervals, we ensure that the solution minimize the cost and satisfy that the begining and the end of the state x_1 on each subintervals corresponds to the value of the singular arc x_s. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_2(t_0)\nend_x₂ : the final state x_2(t_f)\ninit_x₁ : the initial state x_1(t_0)\nN : the number of subdivision of the singular arc\n\nKeyword arguments (optional)\n\nverbose : if true, print the optimization process (default is false)\n\nReturn\n\nreal_sol : the Solution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.synthesis_plot-Tuple{MultiSynthesis}","page":"Developpers","title":"Filtration.synthesis_plot","text":"synthesis_plot(\n    multisynthesis::MultiSynthesis;\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a MultiSynthesis, in a feedback form.\n\nArguments\n\nsynthesis : a MultiSynthesis\n\nKeyword arguments (optional)\n\nkwargs... : keyword arguments for plot \n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.synthesis_plot-Tuple{Synthesis}","page":"Developpers","title":"Filtration.synthesis_plot","text":"synthesis_plot(\n    s::Synthesis;\n    SL_nb_points,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Synthesis, in a feedback form.\n\nArguments\n\ns : a Synthesis\n\nKeyword arguments (optional)\n\nSLnbpoints : Number of points for the switching locus curve. Initialized to nothing (points of the ODESolution`)\nkwargs... : keyword arguments for plot \n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Filtration","category":"page"},{"location":"examples.html#Max-volume-case","page":"Examples","title":"Max volume case","text":"","category":"section"},{"location":"examples.html#Benyahia-et-al.,-2013","page":"Examples","title":"Benyahia et al., 2013","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Benyahia et al., 2013] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,10); mlim = (0,10)\na = 1; b = 1; e = 1\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -p[1] * m\ng(m,p)  = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nmodel = Model(g₁, g₂, f₁, f₂, p, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Cogan-Chellamb,-2014","page":"Examples","title":"Cogan Chellamb, 2014","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Cogan and Chellamb, 2014] and [Cogan and al., 2016] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,40); mlim = (0,10)\na = 1; b = 1; e = 1\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -(p[1] * m) / (p[3] + m)\ng(m,p) = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nmodel = Model(g₁, g₂, f₁, f₂, p, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Kalboussi-et-al.,-2018","page":"Examples","title":"Kalboussi et al., 2018","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Kalboussi et al., 2018] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0, 0.25); mlim = (0,10)\na = 0.64; b = 490.07; d = 4125.6; e = 18.06\np = [a, b, d, e]\n\nf₁(m,p) = p[2] / (p[4] + m)\nf₂(m,p) = -(p[1] * p[3] * m) / (p[4] + m)\ng(m,p) = p[3] / (p[4] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nmodel = Model(g₁, g₂, f₁, f₂, p, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Min-energy-example","page":"Examples","title":"Min energy example","text":"","category":"section"},{"location":"examples.html#Aichouche-et-al.,-2020","page":"Examples","title":"Aichouche et al., 2020","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Aichouche et al., 2020] : ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0,50); mlim = (0,50)\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) = -p[1]*m + p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\n\nmodel = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 20.)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"pareto = Pareto(model)\nplot(pareto, xlabel = \"v̇\", ylabel = \"ė\")","category":"page"},{"location":"examples.html#Ellouze-et-al.,-2023","page":"Examples","title":"Ellouze et al., 2023","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Ellouze et al., 2023] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0, 0.015); mlim = (0, 0.05)\nJv = 2.71e-6; JBW = 5.66e-6;\nC = 2184e-3; β = 1e-6; η = 4.9e-3\nk1f = 2.0769; k2f = 0.0185; k1BW = 9.0551; k2BW = 0.0870\np = [Jv, JBW, C, β, η, k1f, k2f, k1BW, k2BW]\n\nf₁(m,p) = p[3] * p[1] - p[3] * p[1] * p[4] * m\nf₂(m,p) = -p[5] * m\ng₁(m,p) = p[1]\ng₂(m,p) = -p[2]\ne₁(m,p) = p[6] * m + p[7]\ne₂(m,p) = p[8] * m + p[9]\n\nmodel = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 20.)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, SL_nb_points = 10, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"pareto = Pareto(model)\nplot(pareto, xlabel = \"v̇\", ylabel = \"ė\")","category":"page"},{"location":"multisynthesis.html#MultiModel-and-MultiSynthesis","page":"Experimental","title":"MultiModel and MultiSynthesis","text":"","category":"section"},{"location":"multisynthesis.html","page":"Experimental","title":"Experimental","text":"In this part, an experimental part of the code is presented and concerns the case of multiple zero of the function provided by the check_root method exists. In this case, multiple singular arc can occur. ","category":"page"},{"location":"multisynthesis.html","page":"Experimental","title":"Experimental","text":"First, let introduce an exemple of model where there exists multiple zero of the function. ","category":"page"},{"location":"multisynthesis.html","page":"Experimental","title":"Experimental","text":"using Filtration\nusing Plots\n\ne(m,p)  = exp(-m - sin(m)^2)\n\nff(m,p) = 1/(m+1)\nfb(m,p) = -m\nef(m,p) = e(m,p)\neb(m,p) = -e(m,p)\ngf(m,p) = 1.\ngb(m,p) = 1.\n\nplt_root = check_root(ef, eb, ff, fb, [1.], :max, initial_guess = [0.5, 2, 2.5], xlim = (0, 5), linewidth = 2, label = \"Real\")","category":"page"},{"location":"multisynthesis.html","page":"Experimental","title":"Experimental","text":"As we can see, there exists multiple zero of the plotted function. An experimental code is developped to provide the synthesis associaated to this kind of model.","category":"page"},{"location":"multisynthesis.html","page":"Experimental","title":"Experimental","text":"warning: Warning\nThis code was only tested on this example, and not all case are considered. Please be carefull with the solution and don't consider that it provide the truth on another model. ","category":"page"},{"location":"multisynthesis.html","page":"Experimental","title":"Experimental","text":"ylim = (0, 5); xlim = (0, 10)\nmultimodel = MultiModel(ef, eb, ff, fb, [1.], :max, [0.5, 2, 2.5]);\nmultisynthesis = MultiSynthesis(multimodel, xlim, ylim)\nplt = plot(multisynthesis, xlim = xlim, ylim = ylim, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"multisynthesis.html","page":"Experimental","title":"Experimental","text":"<img src=\"https://github.com/remydutto/doc-Filtration.jl/blob/main/ressources/plots/multisynthesis.png?raw=true\" style=\"display: block; margin-left: auto; margin-right: auto;\" width=\"600px\">\n<br>","category":"page"},{"location":"index.html#Filtration-Package","page":"Introduction","title":"Filtration Package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Filtration.jl package.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"},{"location":"solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"In this tutorial, we explain how to handle a solution. First, let's define a model ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"using Filtration\n\nvlim = (0,50); mlim = (0,50)\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) = -p[1]*m + p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\n\nmodel = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 20.)\nnothing; # hide ","category":"page"},{"location":"solution.html#Different-ways-to-get-a-solution","page":"Solution","title":"Different ways to get a solution","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"Given initial and final conditions, the function solve provide the solution.  ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"v0 = 0; vf = 50; m0₁ = 15\nsol₁ = solve(model, v0, vf, m0₁)\nplt = plot(sol₁, label = \"sol₁ \")","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"Another way to obtain a solution is to extract it from a synthesis. This can be achieved thanks to the function solution. ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"synthesis = Synthesis(model, (v0, vf), (0, 50))\nm0₂ = 30.\nsol₂ = solution(synthesis, v0, vf , m0₂)\nplot!(plt, sol₂, color = :red, label = \"sol₂ \")","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"note: Note\nIf the synthesis was generated, the extraction of the solution from the synthesis with the solution function could be faster than the call to the solve function from a model. ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"A final way to obtain a solution is to simulate the model with a used-defined control. In this case, there is no garentee that it is a solution of the defined optimal control problem. ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"However, to do this, we first need to create a control u and to simulate it on the model.  ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"u = Control([t -> 1, t -> sin(0.3*t)], [0, 25, 50], 2, 1)\nx0 = [0, m0₂, 0]\nsol₃ = simulate(model, u, x0)\nplot!(plt, sol₃, color = :green, label = \"sol₃ \")","category":"page"},{"location":"solution.html#State,-control-and-extremal","page":"Solution","title":"State, control and extremal","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"From a Solution, one can extract a State and a Control with the state and the control function. These elements can be called to obtain the value of the state or control at a given time, and can be also plotted. ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"u = control(sol₁)\n\nprintln(\"u(1) = \", u(10))\nplot(u, size = (600, 200))\n","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"x = state(sol₁)\nprintln(\"x(1) = \", x(10))\nplot(x)","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"An extremal can be constructed from a (real) Solution of the problem, computed by the solution function on a Synthesis or the solve function on a Model, i.e. from sol₁ or sol₂ on the previous example. An Extremal must not be created from a Solution created from a used-defined Control, like sol₃. This can be done thanks to the construct_extremal function.","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"z = construct_extremal(model, sol₁)\n\nu = control(z)\nprintln(\"u(1) = \", u(1))\nplot(u, size = (600, 200))","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"x = state(z)\nprintln(\"x(1) = \", x(1))\nplot(x)","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"λ = costate(z)\nprintln(\"λ(1) = \", λ(1))\nplot(λ)","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"The main advantage to get an extremal is to compute Hamiltonians along a trajectory. For instance, t mapsto H_1(x(t) p(t)) corresponds to the switching function for the optimal control. Hamiltonians H, H_0, H_1 and even H_01 are accessible from the model and can be plotted as following.","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"plot( t -> model.H(x(t), λ(t), u(t), p), 0, 50, label = \"H\", ylim = (-1, 1))\nplot!(t -> model.H₀(x(t), λ(t), p), 0, 50, label = \"H₀\")\nplot!(t -> model.H₁(x(t), λ(t), p), 0, 50, label = \"H₁\")\nplot!(t -> model.H₀₁(x(t), λ(t), p), 0, 50, label = \"H₀₁\")","category":"page"}]
}
