var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Cited-References","page":"References","title":"Cited References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"The following references are cited in the documentation.","category":"page"},{"location":"references.html","page":"References","title":"References","text":"F. Aichouche, N. Kalboussi, A. Rapaport, J. Harmand (2020). Modeling and optimal control for production-regeneration systems - preliminary results -, 2020 European Control Conference (ECC)\nB. Benyahia, A. Charfi, N. Benamar, M. Heran, A. Grasmick, B. Cherki, J. Harmand (2013). A simple model of anaerobic membrane bioreactor for control design: coupling the “AM2b” model with a simple membrane fouling dynamics, World Congress on Anerobic Digestion: Recovering (bio) Ressources for the World\nN.G. Cogan, S. Chellam (2014) A method for determining the optimal back-washing frequency and duration for dead-end microfiltration, Journal of Membrane Science\nN.G. Cogan, J. Li, A. R. Badireddy, S. Chellam (2016) Optimal backwashing in dead-end bacterial microfiltration with irreversible attachment mediated by extracellular polymeric substances production, Journal of Membrane Science\nF. Ellouze, Y. Kammoun, N. Kalboussi, A. Rapaport, J. Harmand, S. Nasr, N. Ben Amar (2023) Optimal control of backwash scheduling for pumping energy saving: Application to the treatment of urban wastewater, Journal of Water Process Engineering\nN. Kalboussi, A. Rapaport, T. Bayen, N. Ben Amar, F. Ellouze, J. Harmand (2017) Optimal control of a membrane filtration system, IFAC-PapersOnLine\nN. Kalboussi, J. Harmand, A. Rapaport, T. Bayen, F. Ellouze, N. Ben Amar (2018) Optimal control of physical backwash strategy - towards the enhancement of membrane filtration process performance, Journal of Membrane Science","category":"page"},{"location":"dev-filtration.html#dev-filtration","page":"Developpers","title":"Filtration.jl private functions","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-filtration.html#Index","page":"Developpers","title":"Index","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Pages   = [\"dev-filtration.md\"]\nModules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-filtration.html#Documentation","page":"Developpers","title":"Documentation","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Modules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-filtration.html#Filtration.classification_plot-Tuple{Synthesis}","page":"Developpers","title":"Filtration.classification_plot","text":"classification_plot(\n    s::Synthesis;\n    cut_neg_nb_points,\n    cut_pos_nb_points,\n    SL_nb_points,\n    DL_nb_points,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a Synthesis, with a classification of optimal control.\n\nArguments\n\nsynthesis : a Synthesis\n\nKeyword arguments (optional)\n\ncut_neg_nb_points : number of points to show the cut₋ curve, initialized to nothing (use the points given by the ODESolution)\ncut_pos_nb_points : number of points to show the cut₊ curve, initialized to nothing (use the points given by the ODESolution)\nSL_nb_points : number of points computed for the switching locus curve, initialized to nothing (use the points given by the ODESolution)\nDL_nb_points : number of points computed for the dispersal locus curve, initialized to nothing (use the points given by the ODESolution)\nkwargs... : keyword arguments for plot \n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.costate_-Tuple{AbstractVector{<:Real}, Extremal}","page":"Developpers","title":"Filtration.costate_","text":"costate_(\n    time::AbstractVector{<:Real},\n    extremal::Extremal\n) -> Any\n\n\nCompute the costate p(t) from a vector of times t of an Extremal. \n\nArguments\n\ntime : a vector of times t\nextremal : the Extremal\n\nReturn\n\ncostate : the vector of costate p(t)\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.costate_-Tuple{Real, Extremal}","page":"Developpers","title":"Filtration.costate_","text":"costate_(time::Real, extremal::Extremal) -> Any\n\n\nCompute the costate p(t) from a real time t of an Extremal. \n\nArguments\n\ntime : real time t\nextremal : the Extremal\n\nReturn\n\ncostate : the costate p(t)\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.cuts-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.cuts","text":"cuts(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> Tuple{SciMLBase.ODESolution, SciMLBase.ODESolution}\n\n\nCompute the cuts c_-(t) and c_+(t), which corresponds to the curves which leads to the singular state x_s at time T. The function c is the solution on t_0 T of\n\nleft beginarrayll\n    dot x_0 = e_-(x_1) - e_+(x_1)  quad x_0(T) = 0 dot x_1 = f_-(x_1) - f_+(x_1)  quad x_1(T) = x_s dot x_2 = g_-(x_1) - g_+(x_1)  quad x_2(T) = x_f- Delta_x\nendarray right\n\nand the function m is the solution on T t_f of \n\nleftbeginarrayll\n    dot x_0 = e_-(x_1) + e_+(x_1)  quad x_O(T) = 0 dot x_1 = f_-(x_1) + f_+(x_1)  quad x_1(T) = x_s dot x_2 = g_-(x_1) + g_+(x_1)  quad x_2(T) = x_f - Delta_x\nendarray right\n\nwarning: Warning\nThe cost x_0(T) at time T is initialized to 0. \n\nArguments\n\nmodel : a Model\nxlim : the limits of state x_2\nylim : the limits of state x_1 \n\nReturns\n\ncut₋ : the function c_-\ncut₊ : the function c_+\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.dispersal_locus-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}, SciMLBase.ODESolution}","page":"Developpers","title":"Filtration.dispersal_locus","text":"dispersal_locus(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real},\n    SL::SciMLBase.ODESolution\n) -> SciMLBase.ODESolution\n\n\nDispersal locus function computed by continuation method.\n\nA state x_1 x_2 belongs to the dispersal curve if S(x_2 x_1) = 0, where S colon mathbb R^2 to mathbb R is defined by \n\nS(x_1 x_2) = varphi_0^+(x_1 x_2) - varphi_0^-+(x_1 x_2)\n\nwhere varphi_0^+ correponds to the final cost with the control u₊, and where varphi_0^-+ the final cost with the control u₋ ∘ u₊.  \n\nWe suppose that there exsits the switching locus DL(x_1) such that S(x_1 DL(x_1)) = 0. Since S is constant, we have \n\n    fracpartial Spartial x_1(x_1 DL(x_1)) + fracpartial Spartial x_2(x_1 DL(x_1)) DL(x_1) = 0\n\nBy the previous hypothesis, fracpartial Spartial x_2(x_1 DL(x_1)) is invertible. We have so \n\nDL(x_1) = -left( fracpartial Spartial x_2(x_1 DL(x_1)) right)^-1 fracpartial Spartial x_1(x_1 DL(x_1))\n\nThe continuation method consists to solve this ODE with the initial condition DL(x_s) = x_f - Delta x_2. Thanks to the combinaison of ForwardDiff and OrdinaryDiffEq package, the derivative of varphi_0^+ and varphi_0^-+ are computed by automatic differentiation methods by using the variational equations. \n\nwarning: Warning\nThis function must be used only when a dispersal locus happened, ie. when the end of the switching curve is below ylim[2]. \n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.get_arrow_time-Tuple{Vector{<:Real}, SciMLBase.ODESolution, Symbol}","page":"Developpers","title":"Filtration.get_arrow_time","text":"get_arrow_time(\n    value::Vector{<:Real},\n    sol::SciMLBase.ODESolution,\n    axis::Symbol\n) -> Vector{<:Real}\n\n\nCompute the time t for which sol(t) ∈ y_value\n\nArguments\n\nyvalue : vector of y-axis yvalue\nsol : state trajectory as an ODESolution\n\nReturn\n\ntimes : Vector of times\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve","text":"solve(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real;\n    cut₋,\n    cut₊,\n    SL,\n    DL\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model by indirect shooting.\n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state m_0\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve_MSP-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve_MSP","text":"solve_MSP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model, with the structure given by u_- circ u_s circ u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve_P-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve_P","text":"solve_P(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model, with the structure given by u_+.\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.solve_PSP-Tuple{Model, Real, Real, Real}","page":"Developpers","title":"Filtration.solve_PSP","text":"solve_PSP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting,  with the structure given by u_+ circ u_s circ u_+\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead.  \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0) \n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.state_-Tuple{AbstractVector{<:Real}, Extremal}","page":"Developpers","title":"Filtration.state_","text":"state_(\n    time::AbstractVector{<:Real},\n    extremal::Extremal\n) -> Any\n\n\nCompute the state x(t) from a vector of times t of an Extremal. \n\nArguments\n\ntime : a vector of times t\nextremal : the Extremal\n\nReturn\n\nstate : the vector of state x(t)\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.state_-Tuple{AbstractVector{<:Real}, Solution}","page":"Developpers","title":"Filtration.state_","text":"state_(\n    time::AbstractVector{<:Real},\n    solution::Solution\n) -> Any\n\n\nCompute the state x(t) from a vector of times t of a Solution. \n\nArguments\n\ntime : a vector of times t\nsolution : the Solution\n\nReturn\n\nstate : the vector of state x(t)\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.state_-Tuple{Real, Extremal}","page":"Developpers","title":"Filtration.state_","text":"state_(time::Real, extremal::Extremal) -> Any\n\n\nCompute the state x(t) from a real time t of an Extremal. \n\nArguments\n\ntime : real time t\nextremal : the Extremal\n\nReturn\n\nstate : the state x(t)\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.state_-Tuple{Real, Solution}","page":"Developpers","title":"Filtration.state_","text":"state_(time::Real, solution::Solution) -> Any\n\n\nCompute the state x(t) from a real time t of a Solution. \n\nArguments\n\ntime : real time t\nsolution : the Solution\n\nReturn\n\nstate : the state x(t)\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.switching_locus-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"Developpers","title":"Filtration.switching_locus","text":"switching_locus(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> SciMLBase.ODESolution\n\n\nSwitching locus function computed by continuation method.\n\nA state x_1 x_2 belongs to the switching curve if S(x_2 x_1) = 0, where S colon mathbb R^2 to mathbb R is defined by \n\nS(x_2 x_1) = H(x_1 varphi_1(x_1 x_2))\n\nThe function varphi_1 coresponds to the solution at the final time of the state x_1 by applying the control u_+, and the function H is defined by \n\n    H(x_1 x_1f) = lambda_1(x_1 x_1f) (f_+(x_1) + f_-(x_1)) + lambda_2(x_1f)(g_+(x_1) + g_-(x_1)) - (e_+(x_1) + e_-(x_1))\n\nwhere \n\n    lambda_1(x_1 x_1f) = frace_+(x_1) - lambda_2(x_1f) g_+(x_1)f_+(x_1)\n\nand \n\n    lambda_2(x_1f) =  frace_+(x_1) + e_-(x_1)g_+(x_1) + g_-(x_1) \n\nWe suppose that there exsits the switching locus SL(x_1) such that S(x_1 SL(x_1)) = 0. Since S is constant, we have \n\n    fracpartial Spartial x_1(x_1 SL(x_1)) + fracpartial Spartial x_2(x_1 SL(x_1)) SL(x_1) = 0\n\nBy the previous hypothesis, fracpartial Spartial x_2(x_1 SL(x_1)) is invertible. We have so \n\nSL(x_1) = -left( fracpartial Spartial x_2(x_1 SL(x_1)) right)^-1 fracpartial Spartial x_1(x_1 SL(x_1))\n\nThe continuation method consists to solve this ODE with the initial condition SL(x_s) = x_f - Delta x_2. Thanks to the combinaison of ForwardDiff and OrdinaryDiffEq package, the derivative of varphi_1 is computed by automatic differentiation methods by using the variatomal equations. \n\nArguments\n\nmodel: a Model\nxlim : the limits of the state x_2\nylim : the limits of the state x_1\n\nReturn\n\nSL : the switching locus function, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Filtration","category":"page"},{"location":"examples.html#Max-volume-case","page":"Examples","title":"Max volume case","text":"","category":"section"},{"location":"examples.html#Benyahia-et-al.,-2013","page":"Examples","title":"Benyahia et al., 2013","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Benyahia et al., 2013] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,10); mlim = (0,10)\na = 1; b = 1; e = 1\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -p[1] * m\ng(m,p)  = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nmodel = Model(g₁, g₂, f₁, f₂, p, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Cogan-Chellamb,-2014","page":"Examples","title":"Cogan Chellamb, 2014","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Cogan and Chellamb, 2014] and [Cogan and al., 2016] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0,40); mlim = (0,10)\na = 1; b = 1; e = 1\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -(p[1] * m) / (p[3] + m)\ng(m,p) = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nmodel = Model(g₁, g₂, f₁, f₂, p, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Kalboussi-et-al.,-2018","page":"Examples","title":"Kalboussi et al., 2018","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Kalboussi et al., 2018] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tlim = (0, 0.25); mlim = (0,10)\na = 0.64; b = 490.07; d = 4125.6; e = 18.06\np = [a, b, d, e]\n\nf₁(m,p) = p[2] / (p[4] + m)\nf₂(m,p) = -(p[1] * p[3] * m) / (p[4] + m)\ng(m,p) = p[3] / (p[4] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nmodel = Model(g₁, g₂, f₁, f₂, p, :max)\nsynthesis = Synthesis(model, tlim, mlim)\nplot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Min-energy-example","page":"Examples","title":"Min energy example","text":"","category":"section"},{"location":"examples.html#Aichouche-et-al.,-2020","page":"Examples","title":"Aichouche et al., 2020","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Aichouche et al., 2020] : ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0,50); mlim = (0,50)\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) = -p[1]*m + p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\n\nmodel = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 20.)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"examples.html#Ellouze-et-al.,-2023","page":"Examples","title":"Ellouze et al., 2023","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In [Ellouze et al., 2023] :","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"vlim = (0, 0.015); mlim = (0, 0.05)\nJv = 2.71e-6; JBW = 5.66e-6;\nC = 2184e-3; β = 1e-6; η = 4.9e-3\nk1f = 2.0769; k2f = 0.0185; k1BW = 9.0551; k2BW = 0.0870\np = [Jv, JBW, C, β, η, k1f, k2f, k1BW, k2BW]\n\nf₁(m,p) = p[3] * p[1] - p[3] * p[1] * p[4] * m\nf₂(m,p) = -p[5] * m\ng₁(m,p) = p[1]\ng₂(m,p) = -p[2]\ne₁(m,p) = p[6] * m + p[7]\ne₂(m,p) = p[8] * m + p[9]\n\nmodel = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 20.)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, SL_nb_points = 10, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\")","category":"page"},{"location":"model.html#Model-creation","page":"Model","title":"Model creation","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"In this tutorial, we explain how to create a Model from Filtration.jl package. ","category":"page"},{"location":"model.html#Basic-usage","page":"Model","title":"Basic usage","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Let us start by defining the input functions of the problem ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"using Filtration\n\nap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) =  p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\nnothing; # hide","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"Before creating a model, it is recommended to use the check_root function to ensure that the plotted function have only one root. ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"note: Note\nThe symbol :min correspond to the objective. It can be also :min or :max. This symbol is also used for the creation of the model. ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"check_root(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; xlim = (0, 30))","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"A model of can be created with the following code ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"model = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min)\nnothing; #hide","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"If needed, an initial guess of the zero of the function plot by the check_root function can be provided to the Model","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"model = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min, initial_guess = 20.)\nnothing; #hide","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"If only 4 functions are provided, the functions are set to g_1(\\cdot) = g_2(\\cdot) = 1 to ensure that x_2(t) = t. The following code highlight this case","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"a = 1; b = 1; e = 1;\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -p[1] * m\ng(m,p)  = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\nplt = check_root(g₁, g₂, f₁, f₂, p, :max)\nmodel = Model(g₁, g₂, f₁, f₂, p, :max, initial_guess = 2.)\nplt","category":"page"},{"location":"model.html#Optimal-control-stategies-and-optimal-synthesis","page":"Model","title":"Optimal control stategies and optimal synthesis","text":"","category":"section"},{"location":"model.html","page":"Model","title":"Model","text":"Defining the limits xlim and ylim of the plot, the optimal control stategies plot can be shown from a model by the following code. ","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"warning: Warning\n","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"The maximum limit of the x-axis, i.e. xlim[2] corresponds to the terminal condition of the second state.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"xlim = (0,10); ylim = (0,10)\nsynthesis = Synthesis(model, xlim, ylim)\nplt = plot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\", legend = :bottomright)","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"However, the classical optimal synthesis can be plotted by setting feedback_form = true.","category":"page"},{"location":"model.html","page":"Model","title":"Model","text":"plt = plot(synthesis, feedback_form = true, xlabel = \"Time (t)\", ylabel = \"Mass (m)\", legend = :bottomright)","category":"page"},{"location":"basic-usage.html#Basic-usage","page":"Basic Usage","title":"Basic usage","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The goal of the Filtration.jl package is to provide optimal systesis and optimal solution for a large classe of optimal control problems used for membrane filtration process. There exists mainly two formulation of such optimal control problem which can be found in the litterature.  ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThe provided function given by Filtration.jl package can work whatever the inputs functions are. However, we need to be sure that there exists solutions for this kind of problems and that there exist exacly one root on the domain of interest of a function given by the check_root function. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Here is the used packages to run this page. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"using Filtration\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Max-volume-case","page":"Basic Usage","title":"Max volume case","text":"","category":"section"},{"location":"basic-usage.html#General-description","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"Let us consider the membrane filtration process where the goal is to maximize the water net production ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    max_x(cdot) u(cdot) int_t_0^t_f frac1+u(t)2 g_1(m(t))  + frac1-u(t)2 g_2(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = frac1+u(t)2 f_1(m(t)) + frac1-u(t)2 f_2(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"with the initial condition m(0) = m_0 and where the initial time t_0 and the final time t_f are fixed. ","category":"page"},{"location":"basic-usage.html#Example","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Benyahia et al., 2013] model, where the functions are defined on the following code section. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"note: Note\nThe function 'check_root' and 'Model' need the functions of the model in inputs. The order of these functions is importants. We need to provide first the two function associated to the cost, and after the function(s) associated to the state(s). The (first) state corresponds to the state that is used on the dynamic of all functions. For the order of the couple of functions, we need to provide first the function that multiply the control u. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the check_root function to ensure that there exsit a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"a = 1; b = 1; e = 1;\np = [a, b, e]\n\nf₁(m,p) = p[2] / (p[3] + m)\nf₂(m,p) = -p[1] * m\ng(m,p)  = 1 / (p[3] + m)\ng₁(m,p) = g(m,p)\ng₂(m,p) = -g(m,p)\n\ncheck_root(g₁, g₂, f₁, f₂, p, :max)","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the MaxVolume. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = Model(g₁, g₂, f₁, f₂, p, :max, initial_guess = 2.)\nnothing # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be constructed by the Synthesis function, and plot with the classical plot function","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"tlim = (0,10); mlim = (0,10)\nsynthesis = Synthesis(model, tlim, mlim)\nplt = plot(synthesis, xlabel = \"Time (t)\", ylabel = \"Mass (m)\", legend = :bottomright)","category":"page"},{"location":"basic-usage.html#Solution-trajectories","page":"Basic Usage","title":"Solution trajectories","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function solution extract from the synthesis the optimal trajectory. We can easily add some optimal state trajectories on the previous created plot, thanks to the add_solution_to_synthesis! function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"sol = solution(synthesis, tlim[1], tlim[2], 1)\nadd_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1])\nsol = solution(synthesis, tlim[1], tlim[2], 5)\nadd_solution_to_synthesis!(plt, sol, axis_arrow = :y, element = [1])\nfor t0 ∈ range(tlim[1], tlim[2])\n    sol = solution(synthesis, t0, tlim[2], mlim[1])\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1])\nend\nfor t0 ∈ range(tlim[1], synthesis.SL.u[end], 10)\n    if t0 != synthesis.SL.u[end]\n        sol = solution(synthesis, t0, tlim[2], mlim[2])\n        add_solution_to_synthesis!(plt, sol, axis_arrow = :y, element = [1])\n    end\nend\nfor m0 ∈ range(synthesis.SL.t[1], synthesis.SL.t[end], 10)\n    if m0 != synthesis.SL.t[end] && m0 != synthesis.SL.t[1]\n        t0 = synthesis.SL(m0)\n        sol = solution(synthesis, t0, tlim[2], m0)\n        add_solution_to_synthesis!(plt, sol, axis_arrow = :x)\n    end\nend\nplt","category":"page"},{"location":"basic-usage.html#Min-Energy-case","page":"Basic Usage","title":"Min Energy case","text":"","category":"section"},{"location":"basic-usage.html#General-description-2","page":"Basic Usage","title":"General description","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can also consider another case where the goal is to minimize the energy ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    min_x(cdot) u(cdot) t_f int_t_0^t_f frac1+u(t)2 e_1(m(t)) + frac1-u(t)2 e_2(m(t)) ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"where the control u(cdot) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m(cdot) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot m(t) = frac1+u(t)2 f_1(m(t)) + frac1-u(t)2 f_2(m(t)) quad t in t_0 t_f","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We also want to obtain a final volume v(t_f) = v_f of water at the final time t_f. The dynamic of the state is given by ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"    dot v(t) = frac1+u(t)2 g_1(m(t)) + frac1-u(t)2 g_2(m(t)) quad t in t_0 t_f ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The initial time t_0 is fixed but the final time t_f is free. ","category":"page"},{"location":"basic-usage.html#Example-2","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"In this example, these functions are defined by using the [Aichouche et al., 2020] model, where the functions are defined on the following code section.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can use the check_root function to ensure that there exits a unique zero of the plotted function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"ap = 0; bp = 1; cp = 0.16; dp = 3; Qp = 1\nar = 0.5; cr = 0.64; dr = 12; Qr = 2\np = [ap, bp, cp, dp, Qp, ar, cr, dr, Qr]\n\nf₁(m,p) = -p[1]*m + p[2]\nf₂(m,p) = -p[6]*m\ng₁(m,p) = p[5]\ng₂(m,p) = -p[9]\ne₁(m,p) = p[3]*m + p[4]\ne₂(m,p) = p[7]*m + p[8]\n\ncheck_root(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; xlim = (0, 30))","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"We can provide an initial guess of this zero to the Model. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"model = Model(e₁, e₂, f₁, f₂, g₁, g₂, p, :min; initial_guess = 20.)\nnothing; # hide","category":"page"},{"location":"basic-usage.html#Optimal-synthesis-2","page":"Basic Usage","title":"Optimal synthesis","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The optimal systhesis of this problem can be constructed by the Synthesis function, and plotted thanks to the Plot one. ","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"vlim = (0,50); mlim = (0,50)\nsynthesis = Synthesis(model, vlim, mlim)\nplt = plot(synthesis, xlabel = \"Volume (v)\", ylabel = \"Mass (m)\", legend = :bottomright)","category":"page"},{"location":"basic-usage.html#Solutions-trajectories","page":"Basic Usage","title":"Solutions trajectories","text":"","category":"section"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"The function solution extract from the synthesis the optimal trajectory. We can easily add some optimal state trajectories on the previous created plot, thanks to the add_solution_to_synthesis! function.","category":"page"},{"location":"basic-usage.html","page":"Basic Usage","title":"Basic Usage","text":"sol = solution(synthesis, vlim[1], vlim[2], mlim[2])\nadd_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [2,3])\nfor m0 ∈ range(mlim[1],model.xₛ, 5)\n    sol = solution(synthesis, vlim[1], vlim[2], m0)\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1])\nend\nfor v0 ∈ range(vlim[1],vlim[2], 10)\n    sol = solution(synthesis, v0, vlim[2], mlim[1])\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :x, element = [1])\nend\nfor v0 ∈ range(vlim[1],synthesis.SL.u[end], 10)\n    sol = solution(synthesis, v0, vlim[2], mlim[2])\n    add_solution_to_synthesis!(plt, sol, axis_arrow = :y, element = [1])\nend\nfor m0 ∈ range(synthesis.SL.t[1], synthesis.SL.t[end], 5)\n    if m0 != synthesis.SL.t[end] && m0 != synthesis.SL.t[1]\n        t0 = synthesis.SL(m0)\n        sol = solution(synthesis, t0, tlim[2], m0)\n        add_solution_to_synthesis!(plt, sol, axis_arrow = :x)\n    end\nend\nplt","category":"page"},{"location":"index.html#Filtration-Package","page":"Introduction","title":"Filtration Package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Filtration.jl package.","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"},{"location":"api-filtration.html#Filtration.jl-API","page":"API","title":"Filtration.jl API","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-filtration.html","page":"API","title":"API","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-filtration.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Pages   = [\"api-filtration.md\"]\nModules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-filtration.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Modules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-filtration.html#Filtration.Filtration","page":"API","title":"Filtration.Filtration","text":"Filtration module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataInterpolations\nDocStringExtensions\nFiniteDifferences\nForwardDiff\nLaTeXStrings\nNonlinearSolve\nOptimalControl\nOrdinaryDiffEq\nPlots\nRoots\n\nList of all the exported names:\n\nControl\nExtremal\nModel\nSolution\nSynthesis\nadd_solution_to_synthesis!\ncheck_root\ncompute_phi\nconstruct_extremal\ncostate\nplot\nplot!\nsimulate\nsolution\nsolve_MP\nstate\nto_real_control\n\n\n\n\n\n","category":"module"},{"location":"api-filtration.html#Filtration.Control","page":"API","title":"Filtration.Control","text":"Structure of a Control, composed by \n\ncontrol : a vector of functions\ntime : a vector of times\nN : the number of intervals \n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Extremal","page":"API","title":"Filtration.Extremal","text":"Structure of a Solution, composed by \n\nz : a vector of ODESolution\ncontrol : a Control\ntime : a vector of times\nN : the number of intervals\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Model","page":"API","title":"Filtration.Model","text":"Structure of a Model, composed by:\n\ne₁ : the function e_1(x_1)\ne₁ : the function e_2(x_1)\nf₁ : the function f_1(x_1)\nf₂ : the function f_2(x_1)\ng₁ : the function g_1(x_1)\ng₂ : the function g_2(x_1)\ne₊ : the function e_+(x_1)\ne₋ : the function e_-(x_1)\nf₊ : the function f_+(x_1)\nf₋ : the function f_-(x_1)\ng₊ : the function g_+(x_1)\ng₋ : the function g_-(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\nλ₀ : the constant associated to the criteria type\ndynamics! : the cost and state dynamics function\nde₊ : the function e_+(x_1), compute thanks to ForwardDiff package\nde₋ : the function e_-(x_1), compute thanks to ForwardDiff package\ndf₊ : the function f_+(x_1), compute thanks to ForwardDiff package\ndf₋ : the function f_-(x_1), compute thanks to ForwardDiff package\ndg₊ : the function g_+(x_1), compute thanks to ForwardDiff package\ndg₋ : the function g_-(x_1), compute thanks to ForwardDiff package\nxₛ : the singular state x_s\nuₛ : the singular control u_s\nλ₁ₛ : the singular costate lambda_1s associated to the state x_1 \nλ₂ₛ : the singular costate lambda_2s associated to the state x_2\nΔx₂ : the value Delta_x = x_f - x_2(T), where T is the final time to leave the singular arc\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Model-Tuple{Function, Function, Function, Function, Function, Function, Vector{<:Real}, Symbol}","page":"API","title":"Filtration.Model","text":"Model(\n    e₁::Function,\n    e₂::Function,\n    f₁::Function,\n    f₂::Function,\n    g₁::Function,\n    g₂::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol;\n    initial_guess\n) -> Model\n\n\nConstructor for Model. \n\nArguments\n\ne₁ : the function e_1(x₁)\ne₂ : the function e_2(x₁)\nf₁ : the function f_1(x₁)\nf₂ : the function f_2(x₁)\ng₁ : the function g_1(x₁)\ng₂ : the function g_2(x₁)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for the singular state x_s, initialized to 1.\n\nReturns\n\nmodel : the Model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Model-Tuple{Function, Function, Function, Function, Vector{<:Real}, Symbol}","page":"API","title":"Filtration.Model","text":"Model(\n    e₁::Function,\n    e₂::Function,\n    f₁::Function,\n    f₂::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol;\n    initial_guess\n) -> Model\n\n\nConstructor for Model structure. \n\nnote: Note\nThis function is a wrapper of Model function, where the functions g_+ and g_- are set to 0 and 1 functions, respectively. This leads to dot x_2 = 1 with x_2(t_0) = 0, ie. x_2(t) = t.\n\nArguments\n\ne₊ : the function e_+(x_1)\ne₋ : the function e_-(x_1)\nf₊ : the function f_+(x_1)\nf₋ : the function f_-(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max`\n\nKeyword arguments (optional)\n\ninitial_guess : initial guess for the singular state x_s, initialized to 1.\n\nReturns\n\nmodel : the Model model\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.Solution","page":"API","title":"Filtration.Solution","text":"Structure of a Solution, composed by \n\nstate : a vector of ODESolution\ncontrol : a Control\ntime : a vector of times\nN : the number of intervals\n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Synthesis","page":"API","title":"Filtration.Synthesis","text":"Type of a optimal synthesis, composed by:\n\nmodel : a Model\ntlim : the limits of time t\nxlim : the limits of mass m\ncut₋ : the cut₋ function\ncut₊ : the cut₊ function\nSL : the switching locus\nDL : the dispersal locus\nend_SL : end of the switching locus curve \n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.Synthesis-Tuple{Model, Tuple{Real, Real}, Tuple{Real, Real}}","page":"API","title":"Filtration.Synthesis","text":"Synthesis(\n    model::Model,\n    xlim::Tuple{Real, Real},\n    ylim::Tuple{Real, Real}\n) -> Synthesis\n\n\nConstructor for Synthesis structure. \n\nArguments\n\nmodel : a Model\nxlim : the limits of x-axis, which corresponds to the x_2 state\nylim : the limits of y-axis, which corresponds to the x_1 state\n\nReturns\n\nsynthesis : the Synthesis\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.add_solution_to_synthesis!-Tuple{Plots.Plot, Solution}","page":"API","title":"Filtration.add_solution_to_synthesis!","text":"add_solution_to_synthesis!(\n    plt::Plots.Plot,\n    solution::Solution;\n    element,\n    axis_arrow,\n    arrow,\n    color,\n    nb_pts,\n    kwargs...\n)\n\n\nAdd a Solution to a synthesis plot. \n\nArguments\n\nplt : the synthesis plot\nsolution : the Solution\n\nKeyword arguments (optional)\n\nelement : list of index of solution.state to plot, initialized to [1, ..., solution.N]\narrow : vector of y coordinates to make arrows, initialized to empty\ncolor : color of trajectory, initialized to gray\nnb_pts : number of points for each sub-segments, initialized to 5\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.check_root-Tuple{Function, Function, Function, Function, Function, Function, Union{Nothing, Vector{<:Real}}, Symbol}","page":"API","title":"Filtration.check_root","text":"check_root(\n    e₁::Function,\n    e₂::Function,\n    f₁::Function,\n    f₂::Function,\n    g₁::Function,\n    g₂::Function,\n    p::Union{Nothing, Vector{<:Real}},\n    criteria_type::Symbol;\n    xlim,\n    nb_pts,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the Model type. \n\nArguments\n\ne₁ : the function e_1(x_1)\ne₂ : the function e_2(x_1)\nf₁ : the function f_1(x_1)\nf₂ : the function f_2(x_1)\ng₁ : the function g_1(x_1)\ng₂ : the function g_2(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\nxlim : limits for x axis, initialized to (0,10)\nnb_pts: number of points used for the plot, initialized to 100\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.check_root-Tuple{Function, Function, Function, Function, Vector{<:Real}, Symbol}","page":"API","title":"Filtration.check_root","text":"check_root(\n    e₁::Function,\n    e₂::Function,\n    f₁::Function,\n    f₂::Function,\n    p::Vector{<:Real},\n    criteria_type::Symbol;\n    xlim,\n    nb_pts,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a function where we need to ensure that there is only one zero of it, on the domain of interest. An initial guess of this zero can be provided to the construtor of the Model type. \n\nnote: Note\nThis function is a wrapper of check_root function, where the functions g_+ and g_- are set to 0 and 1 functions, respectively.\n\nArguments\n\ne₊ : the function f_+(x_1)\ne₋ : the function f_-(x_1)\nf₊ : the function g_+(x_1)\nf₋ : the function g_-(x_1)\np : parameters of previous functions\ncriteria_type : the criteria type, either :min or :max\n\nKeyword arguments (optional)\n\nxlim : limits for x axis, initialized to (0,10)\nnb_pts: number of points used for the plot, initialized to 100\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.compute_phi-Tuple{Real, Extremal, Model}","page":"API","title":"Filtration.compute_phi","text":"compute_phi(\n    t::Real,\n    extremal::Extremal,\n    model::Model;\n    p\n) -> Real\n\n\nCompute the value of the function t \\mapsto \\phi(x(t), p(t)) on a given time t of an Extremal computed on a Model. \n\nArguments\n\nt : a real time t\nextremal : the Extremal\nmodel : the Model\n\nKeyword arguments (optional)\n\np : a vector of parameter for the model, initialized by the parametes of the model.\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.construct_extremal-Tuple{Model, Solution}","page":"API","title":"Filtration.construct_extremal","text":"construct_extremal(\n    model::Model,\n    solution::Solution;\n    p\n) -> Extremal\n\n\nConstruct an Extremal from a Solution from a Model.\n\nArguments\n\nmodel : a Model\nsolution: a Solution\n\nReturn\n\nextremal : the Extremal\n\nKeyword arguments (optional)\n\np : a vector of parameter for the model, initialized by the parametes of the model.\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.costate-Tuple{Extremal}","page":"API","title":"Filtration.costate","text":"costate(\n    costate::Extremal\n) -> Filtration.var\"#132#133\"{Extremal}\n\n\nCompute the state function t mapsto p(t) from an Extremal. \n\nArguments\n\nextremal : the Extremal\n\nReturn\n\ncostate : the function t mapsto p(t)\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.simulate-Tuple{Model, Control, Vector{<:Real}}","page":"API","title":"Filtration.simulate","text":"simulate(\n    model::Model,\n    control::Control,\n    x0::Vector{<:Real};\n    p\n) -> Solution\n\n\nSimulate a Control on a Model, starting from and initial state x_0.\n\nArguments\n\nmodel : a Model\ncontrol : a Control\nx0: and intial state x_0\n\nKeyword arguments (optional)\n\np : a vector of parameter for the model, initialized by the parametes of the model.\n\nReturn\n\nsolution : the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solution-Tuple{Synthesis, Real, Real, Real}","page":"API","title":"Filtration.solution","text":"solution(\n    synthesis::Synthesis,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real\n) -> Solution\n\n\nWrapper to get solution from synthesis. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state m_0\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.solve_MP-Tuple{Model, Real, Real, Real}","page":"API","title":"Filtration.solve_MP","text":"solve_MP(\n    model::Model,\n    init_x₂::Real,\n    end_x₂::Real,\n    init_x₁::Real;\n    SL\n) -> Solution\n\n\nSolve the optimal control problem associated to a Model model by indirect method, with the structure given by u_- circ u_+, and when the change is done by intersection with the switching curve\n\nwarning: Warning\nThis function must be used only if we know the structure. If you don't know the structure of the solution, use solve function instead. \n\nArguments\n\nmodel : a Model\ninit_x₂ : the initial state x_1(t_0)\nend_x₂ : the final state x_1(t_f)\ninit_x₁ : the initial state x_2(t_0)\n\nReturns\n\nsol: the Solution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.state-Tuple{Union{Extremal, Solution}}","page":"API","title":"Filtration.state","text":"state(\n    traj::Union{Extremal, Solution}\n) -> Filtration.var\"#130#131\"\n\n\nCompute the state function t mapsto x(t) from a Solution or an Extremal. \n\nArguments\n\ntraj : the Solution or the Extremal\n\nReturn\n\nstate : the function t mapsto x(t)\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot!-Tuple{Plots.Plot, Control}","page":"API","title":"RecipesBase.plot!","text":"plot!(\n    plt::Plots.Plot,\n    control::Control;\n    color,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a control \n\nArguments\n\ncontrol : a Control\n\nKeyword arguments (optional)\n\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Control}","page":"API","title":"RecipesBase.plot","text":"plot(\n    control::Control;\n    color,\n    ylim,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a control \n\nArguments\n\ncontrol : a Control\n\nKeyword arguments (optional)\n\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Extremal}","page":"API","title":"RecipesBase.plot","text":"plot(\n    extremal::Extremal;\n    size,\n    color,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot an extremal\n\nArguments\n\nextremal : an Extremal\n\nKeyword arguments (optional)\n\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#RecipesBase.plot-Tuple{Solution}","page":"API","title":"RecipesBase.plot","text":"plot(\n    solution::Solution;\n    size,\n    color,\n    label,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a solution \n\nArguments\n\nsolution : a Solution\n\nKeyword arguments (optional)\n\nkwargs... : keyword arguments for plot \n\nReturn\n\nplt : the plot\n\n\n\n\n\n","category":"method"}]
}
