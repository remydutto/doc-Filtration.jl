var documenterSearchIndex = {"docs":
[{"location":"references.html#References","page":"References","title":"References","text":"","category":"section"},{"location":"references.html#Cited-References","page":"References","title":"Cited References","text":"","category":"section"},{"location":"references.html","page":"References","title":"References","text":"The following references are cited in the documentation.","category":"page"},{"location":"references.html","page":"References","title":"References","text":"B. Benyahia, A. Charfi, N. Benamar, M. Heran, A. Grasmick, B. Cherki, J. Harmand (2013). A simple model of anaerobic membrane bioreactor for control design: coupling the “AM2b” model with a simple membrane fouling dynamics, World Congress on Anerobic Digestion: Recovering (bio) Ressources for the World\nN.G. Cogan, S. Chellam (2014) A method for determining the optimal back-washing frequency and duration for dead-end microfiltration, Journal of Membrane Science\nN.G. Cogan, J. Li, A. R. Badireddy, S. Chellam (2016) Optimal backwashing in dead-end bacterial microfiltration with irreversible attachment mediated by extracellular polymeric substances production, Journal of Membrane Science\nN. Kalboussi, A. Rapaport, T. Bayen, N. Ben Amar, F. Ellouze, J. Harmand (2017) Optimal control of a membrane filtration system, IFAC-PapersOnLine\nN. Kalboussi, J. Harmand, A. Rapaport, T. Bayen, F. Ellouze, N. Ben Amar (2018) Optimal control of physical backwash strategy - towards the enhancement of membrane filtration process performance, Journal of Membrane Science","category":"page"},{"location":"dev-filtration.html#dev-filtration","page":"Developpers","title":"Filtration.jl private functions","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"CollapsedDocStrings = true","category":"page"},{"location":"dev-filtration.html#Index","page":"Developpers","title":"Index","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Pages   = [\"dev-filtration.md\"]\nModules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]","category":"page"},{"location":"dev-filtration.html#Documentation","page":"Developpers","title":"Documentation","text":"","category":"section"},{"location":"dev-filtration.html","page":"Developpers","title":"Developpers","text":"Modules = [Filtration]\nOrder   = [:type, :module, :constant, :type, :function, :macro]\nPublic  = false","category":"page"},{"location":"dev-filtration.html#Filtration.get_roots_symbolic_algebraic_fraction-Tuple{MembraneFiltrationModel}","page":"Developpers","title":"Filtration.get_roots_symbolic_algebraic_fraction","text":"get_roots_symbolic_algebraic_fraction(\n    model::MembraneFiltrationModel\n) -> Any\n\n\nCompute the positive roots of the function psi. This function works only if the function psi is an algebraic fraction.\n\nnote: Note\nThis function is outdated ! This function may be long to compute due to the use of Symbolics.  However, if it compute, it assure that all positive roots of psi are given. If psi have only one positive root, use singular_state instead.\n\nArguments\n\nmodel : a MembraneFiltrationModel\n\nReturns\n\nroots : the positive roots of psi, i.e. the value of m_s\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.indirect_solve_MP-Tuple{MembraneFiltrationModel, Real, Real, Real}","page":"Developpers","title":"Filtration.indirect_solve_MP","text":"indirect_solve_MP(\n    model::MembraneFiltrationModel,\n    t0::Real,\n    tf::Real,\n    m0::Real;\n    ylim\n) -> Any\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting,  with the structure given by u_- circ u_+.\n\nArguments\n\nmodel : a MembraneFiltrationModel\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial state m(t_0)\nylim : the minimum and maximum limits of state, initialized to (0,10)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.indirect_solve_MSP-Tuple{MembraneFiltrationModel, Real, Real, Real}","page":"Developpers","title":"Filtration.indirect_solve_MSP","text":"indirect_solve_MSP(\n    model::MembraneFiltrationModel,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to the membrane filtration model with the structure given by u_- circ u_s circ u_+.\n\nArguments\n\nmodel : a MembraneFiltrationModel\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial state m(t_0)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.indirect_solve_P-Tuple{MembraneFiltrationModel, Real, Real, Real}","page":"Developpers","title":"Filtration.indirect_solve_P","text":"indirect_solve_P(\n    model::MembraneFiltrationModel,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to the membrane filtration model with the structure given by u_+.\n\nArguments\n\nmodel : a MembraneFiltrationModel\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial state m(t_0)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.indirect_solve_PSP-Tuple{MembraneFiltrationModel, Real, Real, Real}","page":"Developpers","title":"Filtration.indirect_solve_PSP","text":"indirect_solve_PSP(\n    model::MembraneFiltrationModel,\n    t0::Real,\n    tf::Real,\n    m0::Real\n) -> Any\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting,  with the structure given by u_+ circ u_s circ u_+\n\nArguments\n\nmodel : a MembraneFiltrationModel\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial state m(t_0)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.isKfunction-Tuple{Function}","page":"Developpers","title":"Filtration.isKfunction","text":"isKfunction(f::Function; start, stop, N, ε) -> Bool\n\n\nCheck if a function is a K-function.\n\nArguments\n\nf : a function\nstart : the start of the domain, initialized to 0\nstop : the end of the domain, initialized to 100\nN : the number of points, initialized to 100\nε : the precision, initialized to 10^-9\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.isLfunction-Tuple{Function}","page":"Developpers","title":"Filtration.isLfunction","text":"isLfunction(f::Function; start, stop, N, ε) -> Bool\n\n\nCheck if a function is a L-function.\n\nArguments\n\nf : a function\nstart : the start of the domain, initialized to 0\nstop : the end of the domain, initialized to 100\nN : the number of points, initialized to 100\nε : the precision, initialized to 10^-9\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"method"},{"location":"dev-filtration.html#Filtration.ismonotonic","page":"Developpers","title":"Filtration.ismonotonic","text":"ismonotonic(V::AbstractVector) -> Bool\nismonotonic(V::AbstractVector, cmp) -> Bool\n\n\nCheck if a vector is monotonic, with respect to a given comparison operator.\n\nArguments\n\nV : a vector\ncmp : a comparison operator, initialized to >\n\nReturns\n\na boolean\n\n\n\n\n\n","category":"function"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Filtration\nusing Plots","category":"page"},{"location":"examples.html#Benyahia-et-al.-Model","page":"Examples","title":"Benyahia et al. Model","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In the [Benyahia et al., 2013] model, functions f_1 and f_2 are given by ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"f_1(m) = fracbe+m quad f_2(m) = am quad g(m) = frac1e+m ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"where a, b and e are positive numbers.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"a = 1; b = 1; e = 1; t0 = 0; tf = 10\n\nf₁(m) = b ./ (e .+ m)\nf₂(m) = a .* m\ng(m) = 1 ./ (e .+ m)\n\nmodel = MembraneFiltrationModel(f₁, f₂, g)\noptimal_synthesis(model, t0, tf)","category":"page"},{"location":"examples.html#Cogan-Chellamb-model","page":"Examples","title":"Cogan-Chellamb model","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The following functions have been proposed in [Cogan and Chellamb, 2014] and [Cogan and al., 2016]","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"f_1(m) = fracbe+m quad f_2(m) = fracame+m quad g(m) = frac1e+m","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"where a, b and e are positive numbers.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"a = 1; b = 1; e = 1; t0 = 0; tf = 40\n\nf₁(m) = b ./ (e .+ m)\nf₂(m) = (a .* m) ./ (e .+ m)\ng(m) = 1 ./ (e .+ m)\n\nmodel = MembraneFiltrationModel(f₁, f₂, g)\noptimal_synthesis(model, t0, tf)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We can use parameters given in [Kalboussi et al., 2018], computed from more complex model, for variable backswash flux. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"t0 = 0; tf = 0.25 #tf= 7\na₂ = 0.64; b = 490.07; d = 4125.6; e = 18.06;\n\nf₁(m) = b./ (e .+ m)\nf₂(m) = (a₂ * d * m) ./ (e .+ m)\ng(m) = d ./ (e .+ m)\n\nmodel = MembraneFiltrationModel(f₁, f₂, g)\nplt = optimal_synthesis(model, t0, tf)","category":"page"},{"location":"examples.html#Kalboussi-et-Al-model","page":"Examples","title":"Kalboussi et Al model","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The following function has been proposed in [Kalboussi et al., 2018] for constant backwash flux  ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"f_1(m) = fracbe+m quad f_2(m) = a_1 m quad g_1(m) = fracde + m quad g_2(m) = fraca_1a_2 ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"where a_1, a_2, b, d and e are positive number with the following value, computed from a more complex model","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"t0 = 0; tf = 0.25; #tf = 7\na₁ = 91.7; a₂ = 0.64; b = 490.07 ; d = 4125.6 ; e = 18.06 ;\nf₁(m) = b ./ (e .+ m)\nf₂(m) = a₁ .* m\ng₁(m) = d ./ (e.+ m)\ng₂(m) = a₁ ./ a₂\n\nmodel = MembraneFiltrationModel(f₁, f₂, g₁, g₂)\nplt = optimal_synthesis(model, t0, tf)","category":"page"},{"location":"index.html#Filtration-Package","page":"Introduction","title":"Filtration Package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Filtration.jl package. If you are interested in this package, <a href=\"mailto:remy.dutto@orange.fr\">please contact me</a>","category":"page"},{"location":"index.html#Dependencies","page":"Introduction","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"All the numerical simulations to generate this documentation are performed with the following packages.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status()","category":"page"},{"location":"api-filtration.html#Filtration.jl-API","page":"API","title":"Filtration.jl API","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api-filtration.html","page":"API","title":"API","text":"For the developers, here are the private methods.","category":"page"},{"location":"api-filtration.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Pages   = [\"api-filtration.md\"]\nModules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-filtration.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api-filtration.html","page":"API","title":"API","text":"Modules = [Filtration]\nOrder   = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-filtration.html#Filtration.Filtration","page":"API","title":"Filtration.Filtration","text":"Filtration module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nForwardDiff\nLaTeXStrings\nMINPACK\nNemo\nOptimalControl\nOrdinaryDiffEq\nPlots\nRoots\nSymbolics\n\nList of all the exported names:\n\nMembraneFiltrationModel\ncuts\nindirect_solve\noptimal_synthesis\nswitching_locus\n\n\n\n\n\n","category":"module"},{"location":"api-filtration.html#Filtration.MembraneFiltrationModel","page":"API","title":"Filtration.MembraneFiltrationModel","text":"Type of a Membrane Filtration Model, composed by:\n\nf₁ : the function f_1(m)\nf₂ : the function f_2(m)\ng : the function g(m)\nf₊ : the function f_+(m) = 05(f_1(m) + f_2(m))\nf₋ : the function f_-(m) = 05(f_1(m) - f_2(m))\ndg : the function g(m), compute thanks to ForwardDiff package\ndf₊ : the function f_+(m), compute thanks to ForwardDiff package\ndf₋ : the function f_-(m), compute thanks to ForwardDiff package\nstate_dynamic : the state dynamic function, given by f(xu) = f_-(m) + u f_+(m)\ncost_dynamic : the cost dynamic function, given by f^0(xu) = u g(m)\ndynamics! : the cost and state dynamics\nψ : the function psi(m) = g(m) f(m) f_+(m) - f_-(m) f(m) + g(m) f_+(m) f_-(m)\nΦ : the function phi(m lambda) = lambda f_+(m) + g(m)\nmₛ : the singular state m_s, compute as the root of psi\nuₛ : the singular control u_s = - fracf_-(m_s)f_+(m_s)\nλₛ : the singular costate lambda_s = -fracg(m_s)f_+(m_s)\ndynamics₋! : the cost and state dynamics, with u=-1 \ndynamics₊! : the cost and state dynamics, with u=+1\ndynamicsₛ! : the cost and state dynamics, with u=u_s\nΔt : the value Delta t = t_f - t_2, where t_2 is the final time to leave the singular arc\n\nConstructor Arguments\n\nf₁ : the function f_1(m)\nf₂ : the function f_2(m)\ng : the function g(m) \ntest_hypothesis : boolean that indicate if the hypothesis on fonction is tested, initialized to false\n\nDuring the construction, f_1 and g are tested to be L-functions, and f_2 is tested to be a K-function. \n\n\n\n\n\n","category":"type"},{"location":"api-filtration.html#Filtration.cuts-Tuple{MembraneFiltrationModel, Real, Real}","page":"API","title":"Filtration.cuts","text":"cuts(\n    model::MembraneFiltrationModel,\n    t0::Real,\n    tf::Real;\n    ylim\n) -> Tuple{Any, Any}\n\n\nCompute the cuts m_-(t) and m_+(t), which corresponds to the curves which leads to m_s  at time t_2. The function m is the solution of\n\ndot m = f_-(m) - f_+(m) quad m(t_2) = m_s\n\nand the function m is the solution of \n\ndot m = f_-(m) + f_+(m) quad m(t_2) = m_s\n\nwhere t_2 = t_f - Delta t corresponds to the optimal time to exit the singular arc  and m_s the singular state.    \n\nArguments\n\nmodel : a MembraneFiltrationModel\nt0 : the initial time t_0\ntf : the final time t_f\n\nReturns\n\nm₋ : the function m_-, as an ODESolution\nm₊ : the function m_+, as an ODESolution\nylim : the limits of the y-axis, initialized to (0, 10)\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.indirect_solve-Tuple{MembraneFiltrationModel, Real, Real, Real}","page":"API","title":"Filtration.indirect_solve","text":"indirect_solve(\n    model::MembraneFiltrationModel,\n    t0::Real,\n    tf::Real,\n    m0::Real;\n    ylim\n) -> Any\n\n\nSolve the optimal control problem associated to the membrane filtration model by indirect shooting.\n\nArguments\n\nmodel : a MembraneFiltrationModel\nt0 : the initial time t_0\ntf : the final time t_f\nm0 : the initial state m(t_0)\nylim : the minimum and maximum limits of state, initialized to (0,10)\n\nReturns\n\nsol: the solution, as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.optimal_synthesis-Tuple{MembraneFiltrationModel, Real, Real}","page":"API","title":"Filtration.optimal_synthesis","text":"optimal_synthesis(\n    model::MembraneFiltrationModel,\n    t0::Real,\n    tf::Real;\n    ylim\n) -> Plots.Plot\n\n\nPlot the optimal synthesis of a MembraneFiltrationModel.\n\nArguments\n\nmodel : a MembraneFiltrationModel\nt0 : the initial time t_0\ntf : the final time t_f\nylim : the limits of the y-axis, initialized to (0, 10)\n\nReturns\n\nplt : the plot\n\n\n\n\n\n","category":"method"},{"location":"api-filtration.html#Filtration.switching_locus-Tuple{MembraneFiltrationModel, Real}","page":"API","title":"Filtration.switching_locus","text":"switching_locus(\n    model::MembraneFiltrationModel,\n    tf::Real;\n    ylim\n) -> Any\n\n\nCompute the function T(m) which give the time with respect to the deposit mass m which belongs to the switching locus. This function is the solution of \n\nT(m) = frac1f_1(m) - frac gamma(m)g_+(m_T(m)) f_1(m_T(m)) quad T(mₛ) = t_2\n\nwhere m_T(m) = g_+^-1(gamma(m)) and t_2 = t_f - Delta t.  The value of g_+^-1(y) is numerically comute by solving g_+(x) - y = 0.   \n\nArguments\n\nmodel : a MembraneFiltrationModel\ntf : the final time t_f\nylim : the limits of the y-axis, initialized to (0, 10)\n\nReturns\n\nT : the function T(m), as an ODESolution\n\n\n\n\n\n","category":"method"},{"location":"basic-example.html#Description-of-the-problem","page":"Basic Example","title":"Description of the problem","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"Let us consider the membrane filtration process where the goal is to maximize the water net production ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"    max_x(cdot) u(cdot) int_0^T frac1 + u(t)2 g_1big( m(t) big) - frac1 - u(t)2 g_2big( m(t) big) mathrm dt ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"where the control u(cdot) in mathrm L^infty(0T mathbb R) corresponds to the filtration mode (1 during filtration and -1 during backwash) and the state m (cdot) in mathrmAC(0 T mathbb R) is the mass of the cake layer formed during the water filtration. The dynamic of this state is given by ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"    dot m(t) = frac1 + u(t)2 f_1(m(t)) - frac1 - u(t)2 f_2(m(t))","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"with the initial condition m(0) = m_0. ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"In some cases, the cost can also be written in the following form ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"    max_x(cdot) u(cdot) int_0^T u(t) gbig( m(t) big) mathrm dt ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"which corresponds of a spacial case of the general formulation where g_1 = g_2 = g. ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"!!! Tips     In the following code, we can also give functions f_1, f_2 and g to a MembraneFiltrationModel as well as functions f_1, f_2, g_1 and g_2.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"First, we need to have the Filtration.jl package. To solve problems by indirect methods, we use OptimalControl.jl package and MadNLP.jl.  We will also need to import the Plots.jl package.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"using Filtration\nusing OptimalControl\nusing Plots\nusing MadNLP\nnothing; # hide","category":"page"},{"location":"basic-example.html#Example","page":"Basic Example","title":"Example","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"In this example, these functions are defined by using the [Benyahia et al., 2013] model : ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"f_1(m) = fracbe+m quad f_2(m) = am quad g(m) = frac1e+m ","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"where a, b and e are positive numbers. The problem is simply defined, thanks to MembraneFiltrationModel.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"# Benyahia & al. model\na = 1; b = 1; e = 1;\nf₁ = m ->  b ./ (e .+ m)\nf₂ = m -> a .* m\ng  = m -> 1 ./ (e .+ m)\nmodel = MembraneFiltrationModel(f₁, f₂, g)\nnothing; # hide","category":"page"},{"location":"basic-example.html#Direct-Solve","page":"Basic Example","title":"Direct Solve","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"We can solve the optimal control problem by derect method, thanks to the OptimalControl.jl package.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"t0 = 0; m0 = 1; tf = 10;                # initial and final time and state\n@def ocp begin                          # problem definition\n    t ∈ [ t0, tf ], time\n    m ∈ R, state\n    u ∈ R, control\n    -1 ≤ u(t) ≤ 1\n    m(t0) == m0\n    ṁ(t) == model.state_dynamic(m(t),u(t))\n    ∫( model.cost_dynamic(m(t),u(t))) → max\nend\nsol = OptimalControl.solve(ocp, :madnlp)\nplot(sol)","category":"page"},{"location":"basic-example.html#Indirect-solve-and-optimal-synthesis","page":"Basic Example","title":"Indirect solve & optimal synthesis","text":"","category":"section"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"This package develops a code to solve this kind of optimal control problem by indirect methods. Compared to direct method, indirect shooting are known to be more precise and faster. However, to achieve this goal, the sructure of the control need to be konwn beforehand. This step is automaticaly done with the initial time t_0, the final time t_f and the initial state m_0.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"After that, the optimal state and cost trajectory is computed without finding a zero of shooting function. To do this propely, we use the ContinuousCallback fonctionality of the OrdinaryDiffEq.jl package to detect when the control changes. For more information, see this documentation page","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"The output of the indirect_solve function is an ODESolution. The timestep t, the state m and the associated cost m^0 can be obtained via the following code","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"sol = indirect_solve(model, t0, tf, m0)\nt = sol.t\nm = [sol.u[i][2] for i in 1:length(sol.u)]\nm⁰ = [sol.u[i][1] for i in 1:length(sol.u)]\nplot(t, [m, m⁰], layout = [2], size=(600, 300), xlabel = \"time (t)\", labels = nothing, title=[\"State m\" \"Cost m⁰\"])","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"The optimal systhesis of this problem can be easily plot, thanks to the optimal_synthesis function.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"plt = optimal_synthesis(model, t0, tf)","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"We can easily add some optimal state trajectories on the optimal synthesis plot.","category":"page"},{"location":"basic-example.html","page":"Basic Example","title":"Basic Example","text":"ylim = (0, 10)\nfor m0 ∈ range(ylim[1],ylim[2])\n    sol = indirect_solve(model, t0, tf, m0)\n    t = sol.t\n    m  = [sol.u[i][2] for i in 1:length(sol.u)]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nfor t0_ ∈ range(t0,tf)\n    sol = indirect_solve(model, t0_, tf, ylim[1])\n    t = sol.t\n    m  = [sol.u[i][2] for i in 1:length(sol.u)]\n    plot!(plt, t, m, color = :Gray, label = \"\")\n    sol = indirect_solve(model, t0_, tf, ylim[2])\n    t = sol.t\n    m  = [sol.u[i][2] for i in 1:length(sol.u)]\n    plot!(plt, t, m, color = :Gray, label = \"\")\nend\nplt","category":"page"}]
}
